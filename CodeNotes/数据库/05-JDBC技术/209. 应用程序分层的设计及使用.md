# 209. 应用程序分层的设计及使用

<a name="c8TsX"></a>
# 209. 应用程序分层的设计及使用
2.5在分层结构中实现业务<br />上节课的分层,这几节课来进行实现<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/349894/1561371810124-c1aae2eb-2f37-4c61-8bc0-a75e0df1c10f.jpeg#align=left&display=inline&height=195&originHeight=390&originWidth=1107&size=0&status=done&width=554)
<a name="1AC5F"></a>
## 准备工作
首先我们要做的一系列准备工作(在上节课的基础之上进行代码复用):<br />在这个结构的基础之上先导包<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561371810789-ad0746d2-9558-494c-8569-d6ffe0af8c5a.png#align=left&display=inline&height=81&originHeight=81&originWidth=260&size=0&status=done&width=260)<br />把我们的工具类copy到commons的目录之下<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561371810123-b1f49be3-f670-4930-914e-27e611d1e968.png#align=left&display=inline&height=46&originHeight=46&originWidth=166&size=0&status=done&width=166)<br />把我们的proprties文件放在src的目录之下<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561371810124-a69161ae-1a5d-4c92-8a0f-850aabc9db5c.png#align=left&display=inline&height=204&originHeight=204&originWidth=256&size=0&status=done&width=256)<br />再把departments这个模型放到pojo包下<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561371811584-03963627-5baf-43f1-97bc-143200b44023.png#align=left&display=inline&height=50&originHeight=50&originWidth=198&size=0&status=done&width=198)
<a name="mmInz"></a>
## 持久层
我们现在要完成一个队department的查询<br />我们首先做一个接口,注意这个接口是放在dao,而不是dao.impl目录下的<br />注意我们一般持久层的命名都是以dao(数据库访问对象)结尾的<br />然后在这个department的接口里定义包含哪些对部门操作的抽象行为<br />起名的规则:不要包含一些包含业务逻辑的名称,一定要原子化,这样被复用的概率才高,如查询,就叫查询好了,至于被哪个业务定义由那个业务去进行定义<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/349894/1561371810174-286e2365-cae7-4104-ac8a-82185d39370b.jpeg#align=left&display=inline&height=154&originHeight=307&originWidth=1107&size=0&status=done&width=554)<br />持久层的代码要贴近对数据库做了怎样的操作<br />如:根据数据库名称去查找部门表<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/349894/1561371810169-059a3f10-6280-4233-8b55-b24d7d5d5604.jpeg#align=left&display=inline&height=25&originHeight=49&originWidth=1108&size=0&status=done&width=554)<br />添加部门<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/349894/1561371810157-2ad10504-34aa-437d-ae90-24f52f07a57b.jpeg#align=left&display=inline&height=47&originHeight=93&originWidth=1108&size=0&status=done&width=554)<br />当前接口代码:<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/349894/1561371810152-f7a2e57f-9595-475f-8e60-af648b36537f.jpeg#align=left&display=inline&height=212&originHeight=423&originWidth=1108&size=0&status=done&width=554)<br /> 
<a name="I3RPl"></a>
### 接口的实现
接口的实现是在dao层下impl里的<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561371810177-e95c31ea-7f02-4bc6-a227-7f5c51260988.png#align=left&display=inline&height=69&originHeight=69&originWidth=182&size=0&status=done&width=182)<br />接口实现的起名:对哪个接口进行实现,就在后面加个impl<br />再把对应类加进来<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/349894/1561371810172-def04a6e-c73a-45bc-9d8c-564d95b9c731.jpeg#align=left&display=inline&height=462&originHeight=924&originWidth=1108&size=0&status=done&width=554)<br />然后就变成了一个具体实现类,在这里做具体实现<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/349894/1561371810195-df992182-e455-4546-ae88-5e7d8b6f3c67.jpeg#align=left&display=inline&height=281&originHeight=561&originWidth=1108&size=0&status=done&width=554)<br />先写插入,还是固定的套路<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/349894/1561371810162-18063dcf-8578-4672-bbb1-f46a0922b602.jpeg#align=left&display=inline&height=263&originHeight=525&originWidth=1108&size=0&status=done&width=554)<br />然后再写对应的插入语句(注意设置成手动提交,目的是为了培养意识)<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/349894/1561371810348-7df50174-4080-42e2-9e4d-269abf5d2937.jpeg#align=left&display=inline&height=246&originHeight=491&originWidth=1108&size=0&status=done&width=554)<br />还有个查询,结构差不多,只是sql语句有一点点变化,copy过来做一点点修改就好<br />在这里还要新定义一个ResultSet和ArrayList(因为要把查到的结果集放到List当中)<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/349894/1561371810368-a9d676a3-9852-4cb8-a08d-0cc48cc98852.jpeg#align=left&display=inline&height=118&originHeight=236&originWidth=1108&size=0&status=done&width=554)<br />改下sql,事务性语句去掉<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/349894/1561371810352-1ff54a14-4946-450e-97cd-3fbc4e8beb1b.jpeg#align=left&display=inline&height=236&originHeight=471&originWidth=1107&size=0&status=done&width=554)<br />最后把list返回就可以了<br /> 
<a name="y6Gg8"></a>
### 接下来是业务层
业务层的接口是放service包下
<a name="nbDHJ"></a>
#### 接口的起名
1.尽量体现要包含哪些业务<br />2.一般业务层都是一Service结尾的<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/349894/1561371810348-61b01b65-7eea-416d-8446-1f5440810c11.jpeg#align=left&display=inline&height=290&originHeight=580&originWidth=1107&size=0&status=done&width=554)
<a name="UT1FO"></a>
#### 方法的命名
业务层方法的命名贴近这次要做什么样的业务处理<br />如部门的添加<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/349894/1561371810372-1df2fbaa-5082-464b-8547-5a62c7bf6a44.jpeg#align=left&display=inline&height=39&originHeight=78&originWidth=1107&size=0&status=done&width=554)<br />接着就去impl包下放具体的实现类
<a name="7zeQV"></a>
#### 实现的起名
![](https://cdn.nlark.com/yuque/0/2019/jpeg/349894/1561371810350-49cc04e7-f73b-478a-aa37-56a3e609b467.jpeg#align=left&display=inline&height=326&originHeight=652&originWidth=1107&size=0&status=done&width=554)<br />同样在后面加impl<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/349894/1561371810257-7ac05ab9-1b5c-490f-8b56-294363974cb6.jpeg#align=left&display=inline&height=375&originHeight=749&originWidth=926&size=0&status=done&width=463)
<a name="8qDrf"></a>
#### 业务的实现
接下来在这里就可以调用我们的持久层了(我们刚刚已经定义了一个插入部门的方法)<br />因为要用到这个方法因此我们要先创建它<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/349894/1561371810578-10de83db-db13-4151-a874-9597eccb0d04.jpeg#align=left&display=inline&height=152&originHeight=303&originWidth=1107&size=0&status=done&width=554)
<a name="l1xfG"></a>
#### 测试
建立一个测试包定义测试类进行测试<br />先创建一个实体对象并设置参数<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/349894/1561371810973-3d596350-eed5-4894-b7de-e96f86a6d85d.jpeg#align=left&display=inline&height=289&originHeight=578&originWidth=1108&size=0&status=done&width=554)<br />效果:<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/349894/1561371810221-cda1876c-28fc-4dd2-bb34-96d8a8cf4304.jpeg#align=left&display=inline&height=270&originHeight=539&originWidth=611&size=0&status=done&width=306)<br />Dao层的代码就负责操作数据,别的什么都不管,业务层就负责来执行,根据业务需求调用不同的持久层,text层就相当于界面层负责收集用户数据丢给业务层<br />这样的好处是dao的方法业务层的其他方法也能够调用(提高代码复用性)<br /> <br /> <br />2.5.1.1 接口<br />接口<br />public interface DepartmentsDao {<br />public List<Departments> selectDeptByName(String<br />deptName);<br />public void insertDept(Departments dept);<br />}<br />接口实现类<br />public class DepartmentsDaoImpl implements DepartmentsDao {<br />@Override<br />public List<Departments> selectDeptByName(String deptName)<br />{<br />Connection conn = null;<br />PreparedStatement ps = null;<br />ResultSet rs = null;<br />List<Departments> list = new ArrayList<>();<br />try{<br />conn = JdbcUtil.getConnection();<br />ps = conn.prepareStatement("select * from<br />departments where department_name = ?");<br />ps.setString(1, deptName);<br />rs = ps.executeQuery();<br />while(rs.next()){<br />Departments d = new Departments();<br />d.setDepartmentId(rs.getInt("department_id"));<br />d.setDepartmentName(rs.getString("department_name"));<br />d.setLocationId(rs.getInt("location_id"));<br />list.add(d);<br />}<br />}catch(Exception e){<br />e.printStackTrace();<br />JdbcUtil.rollback(conn);<br />}finally{<br />JdbcUtil.closeResource(ps, conn, null);<br />}<br />return list;<br />}<br />@Override<br />public void insertDept(Departments dept) {<br />Connection conn = null;<br />PreparedStatement ps = null;<br />try{<br />conn = JdbcUtil.getConnection();<br />conn.setAutoCommit(false);<br />ps = conn.prepareStatement("insert into departments<br />values(default,?,?)");<br />ps.setString(1, dept.getDepartmentName());<br />ps.setInt(2, dept.getLocationId());<br />ps.execute();<br />conn.commit();<br />}catch(Exception e){<br />e.printStackTrace();<br />JdbcUtil.rollback(conn);<br />}finally{<br />JdbcUtil.closeResource(ps, conn, null);<br />}<br />}<br />}<br />2.5.2业务层<br />2.5.2.1 代码<br />接口<br />public interface DepartmentsService {<br />public void addDepartments(Departments dept);<br />}<br />接口实现类<br />public class DepartmensServiceImpl implements<br />DepartmentsService {<br />@Override<br />public void addDepartments(Departments dept) {<br />DepartmentsDao deptDao = new DepartmentsDaoImpl();<br />deptDao.insertDept(dept);<br />}<br />}<br />2.5.3测试层<br />2.5.3.1 代码<br />public class Test {<br />public static void main(String[] args) {<br />Departments dept = new Departments();<br />dept.setDepartmentName("研发部");<br />dept.setLocationId(30);<br />DepartmentsService ds = new DepartmensServiceImpl();<br />ds.addDepartments(dept);<br />}<br />}
