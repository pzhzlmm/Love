# 210-212

<a name="48e7c393"></a>
# 210. 封装通用的BaseDao实现通用的DML方法
<a name="2a344cd5"></a>
### 什么是BaseDao?
一般架构师在做开发的时候会把一些共性的东西抽取出来作为一个模板,baseDao中就包含一个通用的对数据库进行操作的这么一个模板<br />我们先在对数据库其实就两个,一个dml:insert,update,delete,另外就是select查询操作,我们把这两部分抽取出来做一个通用的模板,以便其他的程序员使用的时候都可以复用这个模板,省去了要去写jdbc这个代码<br />先以封装dml操作为例<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372481722-b27c8b97-beee-472d-914c-5957aebd074e.png#align=left&display=inline&height=621&originHeight=1318&originWidth=1764&status=done&width=831)<br />我们现在就想把他们有共性的地方抽取出来,不同的地方以参数的形式传递到方法里,这样就做了一个通用的执行dml操作的方法
<a name="38164c8b"></a>
## 实现
<a name="b6e28374"></a>
### 定义接口
首先我们在dao包下创建一个接口,来定义通用方法的标准:BaseDao
<a name="caf7bbc3"></a>
#### 定义方法
Int:返回数据库操作的条数<br />现在我们定义就不要具体直线什么表什么对象了,因为我们是一个通用的方法,<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372481828-27b330f8-e379-4196-a7f3-30699a17a9bc.png#align=left&display=inline&height=68&originHeight=45&originWidth=407&status=done&width=611)<br />添加和删除也是一种更新<br />我们不仅要执行insert,update也要执行,所以要一个sql,因为参数可能一个可能多个所以用集合表示<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372481924-e42220d5-f378-4986-b77f-e3f7c4b3a833.png#align=left&display=inline&height=44&originHeight=40&originWidth=749&status=done&width=831)<br />需要一个sql语句,和一个参数列表<br />具体使用:让具体的去集成这个接口<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372482027-c9c91461-f65b-4c8e-961e-c8f0d03f3a17.png#align=left&display=inline&height=213&originHeight=236&originWidth=922&status=done&width=831)<br />我们现在还得编写一个baseDao的子类,谁用谁集成自它直接继承就好了<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372482089-8840596e-f67f-4b1f-ae54-7796096f261f.png#align=left&display=inline&height=545&originHeight=389&originWidth=593&status=done&width=831)

这个参数可能是一个,也可能是多个<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372482156-8ccfca8b-f9b4-4d30-8417-12b9398ebe4e.png#align=left&display=inline&height=54&originHeight=74&originWidth=1129&status=done&width=831)
<a name="38164c8b-1"></a>
### 实现
通用的结构先搭建好<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372482230-5b54cbed-6857-4fe2-b03a-7a56a8356df6.png#align=left&display=inline&height=503&originHeight=603&originWidth=996&status=done&width=831)
<a name="568ce2aa"></a>
#### PreparedStatement助攻
通过PreparedStatement的方法我们可以得到参数的个数<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372482308-a66e40d9-4cb8-4926-adcc-50cdd7b10f5e.png#align=left&display=inline&height=73&originHeight=60&originWidth=684&status=done&width=831)<br />换句话说参数里的所有信息都封装到了ParameterMetaData包下<br />这个对象下有个获取数据(问号)的按方法<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372482362-b2281224-d876-4aef-b45f-2262bfaff955.png#align=left&display=inline&height=49&originHeight=53&originWidth=891&status=done&width=831)<br />而PreparedStatement本身除了setInt,setString,还有模糊性的setObject的方法,通过这个方法我们可以忽略其具体类型,都当做对象去绑定,这就帮我们在传入参数不清楚的时候可以进行传参<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372482429-c7a367b5-c5eb-431e-b379-0d696826589a.png#align=left&display=inline&height=188&originHeight=162&originWidth=715&status=done&width=831)
<a name="38164c8b-2"></a>
#### 实现
![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372482500-58b728df-4910-468b-ba94-4a467409f4a0.png#align=left&display=inline&height=632&originHeight=674&originWidth=886&status=done&width=831)<br />别忘了添加事务<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372482605-386bcaa0-e417-4f90-9a44-e87e5d778a36.png#align=left&display=inline&height=625&originHeight=1132&originWidth=1504&status=done&width=831)
<a name="6d52805d"></a>
### 通用方法的使用
以departmentdao为例,现在有个innsert,<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372482714-acbe8138-2cb1-412c-af9f-18898e4a9600.png#align=left&display=inline&height=141&originHeight=156&originWidth=920&status=done&width=831)<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372482823-fec0b3be-2c36-4e44-afa7-da35e9c953af.png#align=left&display=inline&height=423&originHeight=891&originWidth=1751&status=done&width=831)<br />不管它,做为比较,现在添加个update<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372482901-b466db7f-af65-4eda-b5e9-a02dd6d0f2b9.png#align=left&display=inline&height=177&originHeight=198&originWidth=928&status=done&width=831)
<a name="ac6b12a4"></a>
#### 然后实现
具体实现是我们自己去传参,自己去写JDBC,现在画风变了<br />先把要定义的语句写好<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372482952-8121cf48-3984-47ef-8218-ccb1cbc3cb52.png#align=left&display=inline&height=47&originHeight=34&originWidth=297&status=done&width=410) ![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372483015-d440627c-13fb-4000-9012-e02ac18408c0.png#align=left&display=inline&height=30&originHeight=40&originWidth=1116&status=done&width=831)<br />定义参数列表(注意参数列表的位置要和?的位置一一对应)<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372483071-8e4d882d-a8f9-4234-bdb1-ab41b30d9062.png#align=left&display=inline&height=56&originHeight=37&originWidth=440&status=done&width=660)<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372483139-4c6c25f7-9044-43d8-8540-ed2cab107478.png#align=left&display=inline&height=29&originHeight=35&originWidth=997&status=done&width=831)<br />接下来调用父类的方法把参数传进去就好了<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372483193-41ce9558-c8b6-45b8-a35e-d1ac9bf2092a.png#align=left&display=inline&height=27&originHeight=36&originWidth=554&status=done&width=415)<br />完整版:是不是简洁很多:<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372483255-9dd5809d-521f-4b4d-8102-606719e9cda0.png#align=left&display=inline&height=117&originHeight=154&originWidth=1095&status=done&width=831)

<a name="a0de5dc8"></a>
### 业务层调用
![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372483320-3c88d2b1-472e-4139-9f77-750de0f3e28c.png#align=left&display=inline&height=359&originHeight=331&originWidth=767&status=done&width=831)<br />接口实现类中进行实现,<br />为什么不能直接new baseDao?里面没有sql语句啊,sql语句是子类根据自己需要所定义的<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372483398-e56853e1-024b-4514-b6da-dd67b4101b12.png#align=left&display=inline&height=541&originHeight=683&originWidth=1050&status=done&width=831)
<a name="db06c78d-1"></a>
### 测试
![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372483476-3d115a52-549f-4d38-b02f-d79587ecd438.png#align=left&display=inline&height=365&originHeight=399&originWidth=908&status=done&width=831)<br />效果<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372483550-d7176e8f-a584-4853-b354-46dc4d375336.png#align=left&display=inline&height=441&originHeight=356&originWidth=373&status=done&width=462)
<a name="4876a527"></a>
### 实现2删除
<a name="Dao"></a>
#### Dao
接下来又做了个删除操作代码如下,道理同样<br />Dao<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372483617-56aae4d1-ec85-48a7-8804-a404f7fd1255.png#align=left&display=inline&height=198&originHeight=222&originWidth=933&status=done&width=831)<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372483683-91985041-7acb-42df-bb5f-26138f56421f.png#align=left&display=inline&height=154&originHeight=185&originWidth=996&status=done&width=831)
<a name="Service"></a>
#### Service
![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372483748-3f3ad647-709d-4f3a-8bdf-a904cccaa3c7.png#align=left&display=inline&height=356&originHeight=328&originWidth=765&status=done&width=831)<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372483822-dbea4faa-4fbb-4e36-b658-17255a67d96e.png#align=left&display=inline&height=187&originHeight=178&originWidth=791&status=done&width=831)
<a name="db06c78d-2"></a>
#### 测试
![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372483895-566a7d53-8b14-4835-8ca3-197aa1c18741.png#align=left&display=inline&height=398&originHeight=409&originWidth=855&status=done&width=831)<br />因此以后实现直接给参数和语句就可以了<br />3 封装通用的 BaseDao<br />3.1封装更新操作<br />3.1.1代码<br />接口<br />public interface BaseDao {<br />public int executeUpdate(String sql,Object[] param);<br />}<br />接口实现类<br />public class BaseDaoImpl implements BaseDao {<br />/**<br />* 封装通用的 DML 操作<br />*/<br />@Override<br />public int executeUpdate(String sql, Object[] param) {<br />Connection conn =null;<br />PreparedStatement ps = null;<br />int rows = 0;<br />try{<br />conn = JdbcUtil.getConnection();<br />conn.setAutoCommit(false);<br />ps = conn.prepareStatement(sql);<br />//得到参数的个数<br />ParameterMetaData pmd = ps.getParameterMetaData();<br />//绑定参数<br />for(int i=0;i<pmd.getParameterCount();i++){<br />ps.setObject(i+1, param[i]);<br />}<br />rows = ps.executeUpdate();<br />conn.commit();<br />}catch(Exception e){<br />e.printStackTrace();<br />JdbcUtil.rollback(conn);<br />}finally{<br />JdbcUtil.closeResource(ps, conn, null);<br />}<br />return rows;<br />}<br />}<br />Dao 层代码 接口<br />public interface DepartmentsDao extends BaseDao {<br />public List<Departments> selectDeptByName(String<br />deptName);<br />public void insertDept(Departments dept);<br />public int updateDept(Departments dept);<br />public int deleteDeptById(int departmentId);<br />}<br />Dao 层接口实现类<br />public class DepartmentsDaoImpl extends BaseDaoImpl implements<br />DepartmentsDao {<br />@Override<br />public List<Departments> selectDeptByName(String deptName)<br />{<br />Connection conn = null;<br />PreparedStatement ps = null;<br />ResultSet rs = null;<br />List<Departments> list = new ArrayList<>();<br />try{<br />conn = JdbcUtil.getConnection();<br />ps = conn.prepareStatement("select * from<br />departments where department_name = ?");<br />ps.setString(1, deptName);<br />rs = ps.executeQuery();<br />while(rs.next()){<br />Departments d = new Departments();<br />d.setDepartmentId(rs.getInt("department_id"));<br />d.setDepartmentName(rs.getString("department_name"));<br />d.setLocationId(rs.getInt("location_id"));<br />list.add(d);<br />}<br />}catch(Exception e){<br />e.printStackTrace();<br />JdbcUtil.rollback(conn);<br />}finally{<br />JdbcUtil.closeResource(ps, conn, null);<br />}<br />return list;<br />}<br />@Override<br />public void insertDept(Departments dept) {<br />Connection conn = null;<br />PreparedStatement ps = null;<br />try{<br />conn = JdbcUtil.getConnection();<br />conn.setAutoCommit(false);<br />ps = conn.prepareStatement("insert into departments<br />values(default,?,?)");<br />ps.setString(1, dept.getDepartmentName());<br />ps.setInt(2, dept.getLocationId());<br />ps.execute();<br />conn.commit();<br />}catch(Exception e){<br />e.printStackTrace();<br />JdbcUtil.rollback(conn);<br />}finally{<br />JdbcUtil.closeResource(ps, conn, null);<br />}<br />}<br />//更新部门信息<br />@Override<br />public int updateDept(Departments dept) {<br />String sql = "update departments set department_name<br />= ? ,location_id = ? where department_id = ?";<br />Object[] param = new<br />Object[]{dept.getDepartmentName(),dept.getLocationId(),dept.ge<br />tDepartmentId()};<br />return this.executeUpdate(sql, param);<br />}<br />//删除部门信息<br />@Override<br />public int deleteDeptById(int departmentId) {<br />String sql = "delete from departments where department_id<br />= ?";<br />Object[] param = new Object[]{departmentId};<br />return this.executeUpdate(sql, param);<br />}<br />}
<a name="912522b3"></a>
# 211.封装查询操作
我封装的这个表,可以对数据库中任意一个表去做查询操作<br />同样其他地方相通,就这个地方并不一致<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372483988-0b4ea6ec-1de4-4198-aa3e-25b97e2eacf9.png#align=left&display=inline&height=476&originHeight=1010&originWidth=1762&status=done&width=831)<br />所以查询难在要做一个通用的结果集
<a name="c1921a32"></a>
## 定义抽象查询方法
执行什么sql语句,绑定的参数,查询到的结果封装到哪个对象里(把类给我,然后再通过反射区建立对象)<br />返回的是一个集合,类型是泛型,T代表一个占位,意思是你给我什么类型,我接收的就是什么类型占位的意思<br />之前加<T>表示当前方法是一个泛型方法<br />也可以在接口那里定义<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372484064-df4be7a2-6b0c-436b-ab15-a348dbdd8d98.png#align=left&display=inline&height=96&originHeight=64&originWidth=491&status=done&width=737)<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372484128-57683487-55e4-40f1-8f21-b9c03e1c3288.png#align=left&display=inline&height=330&originHeight=410&originWidth=1031&status=done&width=831)
<a name="38164c8b-3"></a>
## 实现
<a name="138a6766"></a>
### 注意
<a name="62dee69d"></a>
#### ORM:
把我们查到的结果集放到对象当中,<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372484193-9899b570-2219-4d6e-99db-d387876ddeda.png#align=left&display=inline&height=190&originHeight=193&originWidth=842&status=done&width=831)<br />这个操作 我们叫做ORM<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372484253-a418b436-40b4-462b-8ae0-759f5050b76d.png#align=left&display=inline&height=75&originHeight=50&originWidth=388&status=done&width=582)<br />对象关系映射:从关系数据库中把数据拿出来,放到对象当中<br />在关系型数据库中我们对ORM的处理完全依赖于手动去处理,后面我们学的myd??是一个自动的框架,对这样的行为我们再不用写了,完全由框架去帮我们去完成整个过程
<a name="9da18849"></a>
#### 映射
问题是,我们怎么把某个列的值去放到对应的属性中呢?<br />所以我们就有个前提要求,要保证我们表的字段名和我们对象的属性名保持一致,这样可以直接通过属性名去作为获取拿一个列的标识<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372484303-16199c4c-e9ef-4155-88ef-455fd971dff9.png#align=left&display=inline&height=39&originHeight=36&originWidth=761&status=done&width=831)<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372484367-bff48027-70e0-447f-9749-dc0579ef1fc6.png#align=left&display=inline&height=267&originHeight=178&originWidth=430&status=done&width=645)<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372484432-fd7d240c-f039-496e-b871-4fe78842aa3d.png#align=left&display=inline&height=278&originHeight=195&originWidth=582&status=done&width=831)<br />接着设置getset方法
<a name="af2e7927"></a>
#### 套路
还是这个框架<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372484519-cc0b6e16-0c76-413a-86a6-04e769a10b1b.png#align=left&display=inline&height=412&originHeight=782&originWidth=1579&status=done&width=831)
<a name="e17128ee"></a>
#### 绑定参数,设置sql
绑定参数的部分也可以直接从处理dml那里直接copy下来,都一样的<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372484594-1c6d24ad-5cf1-4e31-b93b-cbb5b75d44ab.png#align=left&display=inline&height=322&originHeight=315&originWidth=814&status=done&width=831)
<a name="0d512a89"></a>
#### 处理结果集
接下来返回一个结果集<br />先通过resultset拿到结果集,然后while,以往我们new具体对象,赋值装进对应的对象就好了,但这里不行了<br />通过反射用传进去的的类名new一个新的对象出来<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372484660-5eb46a0b-4b4d-45d3-84fc-72b98af7d96d.png#align=left&display=inline&height=46&originHeight=54&originWidth=975&status=done&width=831)<br />如果这里不写T,它会用默认的Object类型,用泛型的方式去做instance的处理
<a name="803989af"></a>
##### 属性问题
接下来我们需要考虑的就是返回的结果集具体有多少列?我们得循环把每一列都取出来放到我们的属性中<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372484722-bd133cc3-7c29-4071-9326-58bd4b6f8cc5.png#align=left&display=inline&height=275&originHeight=183&originWidth=391&status=done&width=587)<br />所以我们就要知道具体有多少列,如此就要依赖于resultset方法了<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372484784-86f53f89-0fa6-473f-a429-9e55d308820d.png#align=left&display=inline&height=79&originHeight=91&originWidth=953&status=done&width=831)<br />里面刚刚好有个返回列数的方法<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372484846-cb173e71-7b35-4126-867f-dffadd4ceb9c.png#align=left&display=inline&height=74&originHeight=49&originWidth=433&status=done&width=650)<br />列的个数就决定了我区分多少列<br />然后通过我拿到的名字,去设置我对应的子类的属性值,<br />到此为止,处理结果集<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372484919-2ce5e4e5-21da-4790-a746-69f4f50757c8.png#align=left&display=inline&height=484&originHeight=427&originWidth=733&status=done&width=831)<br />除此之外,我们还可以使用apache的一个开源的处理工具.<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372484999-94f3e97a-3df2-4632-a370-3a7f865e90d8.png#align=left&display=inline&height=218&originHeight=164&originWidth=625&status=done&width=831)<br />它的作用就是向对象中的某个属性去放值这样的通用操作的<br />我们现在就不用用反射了<br />通过位置拿到列名,列名又和我们的属性相通,就可以通过BeanUtil放进去了<br />拿到列名之后就去哪这个列的值<br />接着就可以用BeanUtil的方法往类里面放值了,里面的三个参数分别是:往哪个对象里放,属性名叫什么,放的值是什么<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372485073-fbec2249-b992-481c-ad3f-0c7b06f19177.png#align=left&display=inline&height=355&originHeight=377&originWidth=883&status=done&width=831)<br />这个循环每执行一圈就一个一个地把列名依次放了进去<br />接着别忘了把得到的值加入集合<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372485141-ae9714b9-a3d8-44ed-9d81-45e1943dc3e2.png#align=left&display=inline&height=401&originHeight=402&originWidth=833&status=done&width=831)<br />最后返回List就可以了<br />如此我们就写好了一个通用的查询方法
<a name="3efc3237"></a>
## 数据层使用
<a name="432b04f9"></a>
### 接口定义
![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372485210-27f48318-57dd-401d-bbbe-1f95ac0e5e14.png#align=left&display=inline&height=284&originHeight=305&originWidth=891&status=done&width=831)
<a name="380cf2b5"></a>
### 具体实现
通用只需要写语句和参数就可以了<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372485277-d5347b49-c63a-4d49-9cc6-4587da6179e7.png#align=left&display=inline&height=161&originHeight=213&originWidth=1098&status=done&width=831)<br />结果:<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372485340-05665543-73c1-485e-bd14-9b98a3c5f01d.png#align=left&display=inline&height=344&originHeight=229&originWidth=458&status=done&width=687)
<a name="30229c5a"></a>
### 业务层
<a name="54ea89b4"></a>
#### 接口
![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372485417-59151653-3180-4391-a0af-5f439a4730f6.png#align=left&display=inline&height=468&originHeight=493&originWidth=875&status=done&width=831)
<a name="d9356b46"></a>
#### 接口实现类
![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372485479-cc3e0a80-bb81-4461-bf2a-b12e31fc6ff5.png#align=left&display=inline&height=182&originHeight=177&originWidth=807&status=done&width=831)
<a name="a286647b"></a>
## 测试类


通用只需要<br />3.2.1代码<br />BaseDao 接口<br />public interface BaseDao {<br />public int executeUpdate(String sql,Object[] param);<br />public <T> List<T> find(String sql,Object[] param,Class<T><br />clazz);<br />}<br />BaseDaoImpl 接口实现类<br />@Override<br />public <T> List<T> find(String sql, Object[] param, Class<T><br />clazz) {<br />Connection conn =null;<br />PreparedStatement ps =null;<br />ResultSet rs = null;<br />List<T> list = new ArrayList<>();<br />try{<br />conn = JdbcUtil.getConnection();<br />ps = conn.prepareStatement(sql);<br />//得到参数的个数<br />ParameterMetaData pmd = ps.getParameterMetaData();<br />//绑定参数<br />for(int i=0;i<pmd.getParameterCount();i++){<br />ps.setObject(i+1, param[i]);<br />}<br />//处理结果集<br />rs = ps.executeQuery();<br />//获取结果集的信息<br />ResultSetMetaData rsmd = rs.getMetaData();<br />while(rs.next()){<br />//完成 ORM 处理：通过 jdk 的反射<br />T bean =clazz.newInstance();//Departmens d = new<br />Department();<br />for(int i=0;i<rsmd.getColumnCount();i++){<br />//得到列名<br />String columnName = rsmd.getColumnName(i+1);<br />//获取列的值<br />Object value = rs.getObject(columnName);<br />//通过 BeanUtil 工具类将值当如到对象中<br />BeanUtils.setProperty(bean, columnName,<br />value);<br />}<br />list.add(bean);<br />}<br />}catch(Exception e){<br />e.printStackTrace();<br />}finally{<br />JdbcUtil.closeResource(ps, conn, rs);<br />}<br />return list;<br />}<br />DepartmentDao 接口<br />public interface DepartmentsDao extends BaseDao {<br />public List<Departments> selectDeptByName(String<br />deptName);<br />public void insertDept(Departments dept);<br />public int updateDept(Departments dept);<br />public int deleteDeptById(int departmentId);<br />public List<Dept> selectDeptByLikeName(String deptName);<br />}<br />DepartmentDaoImpl 接口实现类<br />@Override<br />public List<Dept> selectDeptByLikeName(String deptName) {<br />String sql ="select * from departments where<br />department_name like ?";<br />Object[] param = new Object[]{"%"+deptName+"%"};<br />return this.find(sql, param, Dept.class);<br />}
<a name="664eca23"></a>
# 212. JDBC驱动加载原理 
4 JDBC 驱动加载原理<br />4.1创建对象的方式<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372485562-cadc5038-8fdd-4e40-9ef5-623b4189ebe8.png#align=left&display=inline&height=294&originHeight=380&originWidth=1074&status=done&width=831)<br />4.2创建对象时三个重要的步骤<br />?通过类加载器加载 class:我们的class在磁盘中放着,这个过程就是把它加到内存当中<br />?初始化所有静态部分:包括类中的静态方法,静态变量,静态化初始块等等,即静态优先级是最高的,这也说明了,为什么静态方法中不能访问非静态的方法和变量<br />我们用反射去初始化一个对象的时候只执行了前两个部分,也就是说初始化了所有的静态部分,对象还没有具体的分配出来,说明时候newinstance了,什么时候再去做第三步

我们连接的时候为什么要写class.forname呢?<br />这是我们实例化数据库驱动的一个方式,因为只有把它实例化出来了,我们才能通过这个对象来创建链接<br />实例化出来之后,通过drivermanager来创建链接<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372485615-0644010d-1637-40a5-af8e-523b210b18c3.png#align=left&display=inline&height=34&originHeight=40&originWidth=989&status=done&width=831)
<a name="5b804b05"></a>
### 源码
Driver这个类是数据库,也就是mysql提供的<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372485687-fec3d822-7b99-47e3-bcda-0bfe1474c5ac.png#align=left&display=inline&height=268&originHeight=368&originWidth=1139&status=done&width=831)<br />它实现了driver的一个接口,这个接口中又个connect的方法<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372485753-28d8402e-1d6f-4c4e-89a4-ecf7e2e2a03e.png#align=left&display=inline&height=235&originHeight=288&originWidth=1019&status=done&width=831)<br />这个方法是让不同数据库厂商去实现的,具体怎么去链接让定义在connect里面<br />接下来看NonRegisteringDriver类<br />如是找到了connect类<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372485828-2376d31f-9524-4276-a873-de545c050561.png#align=left&display=inline&height=431&originHeight=683&originWidth=1004&status=done&width=633)<br />这部分代码就是与自己数据库建立 链接的一个方法,然后最后返回一个connection,也就是每次我们去获取连接时候都会去调用这个方法<br />但是我们调用的不是这个方法啊?<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372485903-5f26be81-3126-4d16-a4ab-16910161dd24.png#align=left&display=inline&height=29&originHeight=35&originWidth=991&status=done&width=831)<br />在driver类里有个static块<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1561372485979-4739f742-96b7-4851-94a8-af66a28122ad.png#align=left&display=inline&height=506&originHeight=584&originWidth=960&status=done&width=831)<br />也就是说我们forname的时候就会执行这段静态代码块,把自己给实例化出来了<br />也就是说它通过静态化初始块,把自己new了出来,然后调用drivermanager的registerDriver,把自己交给了 drivermanager<br />接下来我们调用drivermanager的getconnection去调用父类的connect方法获取到一个链接<br />?为新生对象分配内存<br />4.3MySQL 驱动类的实例化过程<br />static {<br />try {<br />java.sql.DriverManager.registerDriver(new Driver());<br />} catch (SQLException E) {<br />throw new RuntimeException("Can't register driver!");<br />}<br />}


