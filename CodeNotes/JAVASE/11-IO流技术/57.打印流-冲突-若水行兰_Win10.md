# 57.打印流


1. 简述PrintStream的特点？
  1. 提供了一系列的print和println,可以把基本数据类型的数据格式化成字符输出,输出功能非常强大,方法也不用抛出
2. 简述PrintWriter与PrintStream的区别？
  1. PrintStream对应字符流,功能相同,方法对应
  1. PrintStream不会爆出IO异常
  1. PrintStream复制时可以BufferedWirater对应,读各种各样的基本数据

![](https://cdn.nlark.com/yuque/0/2019/png/349894/1560141060105-afacd58a-8246-45f6-82f7-2dcefbcaa273.png#align=left&display=inline&height=132&originHeight=263&originWidth=720&status=done&width=360)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560140415740-aef73fac-6bc1-47ca-872f-94b01cadd26a.png#align=left&display=inline&height=242&name=image.png&originHeight=484&originWidth=798&size=343514&status=done&width=399)<br />print输出的所有内容最终都转换成字符串了<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560140518741-b999b005-ded2-4500-a177-3aa4db2394a2.png#align=left&display=inline&height=128&name=image.png&originHeight=255&originWidth=620&size=78255&status=done&width=310)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560140558712-4fb6d016-bf5d-44be-aaff-1d8588fcb6f2.png#align=left&display=inline&height=75&name=image.png&originHeight=149&originWidth=348&size=45661&status=done&width=174)是这个的一个子类<br />因此我们打印输出除了system还可以这样<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560140604254-a5333aac-5f60-4904-aa5f-de6f34225144.png#align=left&display=inline&height=234&name=image.png&originHeight=468&originWidth=808&size=248921&status=done&width=404)<br />也可以这样<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560140623299-fd3bdcc5-2ce3-4874-83e7-9bc54a654497.png#align=left&display=inline&height=30&name=image.png&originHeight=60&originWidth=425&size=46101&status=done&width=212.5)<br />根本没有抛出IO异常,而且可以输出到文件当中去<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560140746458-dd6d83cc-bbf2-4787-880d-0a653539d967.png#align=left&display=inline&height=16&name=image.png&originHeight=31&originWidth=1205&size=56369&status=done&width=602.5)


只有输出打印流,没有输入打印流<br />打印到文件当中去<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560140775875-6816dd37-68d6-4255-819b-7a1d0da74672.png#align=left&display=inline&height=19&name=image.png&originHeight=39&originWidth=1184&size=84438&status=done&width=592)<br />我们的字符流是需要刷新缓冲的<br />因为根本没有字符流,当我们在创建字符流的对象的时候,底层创建的都是字节流,我们的字符是在缓冲当中产生的,所以在使用字符流的时候,还需要记得要手动刷新<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560140905433-855e0c7e-1304-4095-9244-48551d103fab.png#align=left&display=inline&height=116&name=image.png&originHeight=232&originWidth=1062&size=185745&status=done&width=531)<br />否则我们的数据停在缓存当做,而不会到目的地<br />效果如下啊<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560140947367-e7c2c4e7-aafa-4913-9862-59a9a250b197.png#align=left&display=inline&height=96&name=image.png&originHeight=192&originWidth=427&size=62615&status=done&width=213.5)

打印流本身很强大,但它打印输出之后就变成了字符串,却失去它原本的类型<br />如读取后<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560141014737-31b4af10-a184-4f2f-b975-fe19488745df.png#align=left&display=inline&height=204&name=image.png&originHeight=407&originWidth=1690&size=456488&status=done&width=845)<br />每个字符值都有个对应的UNICODE编码值,失去了原来的数据类型<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560141060105-afacd58a-8246-45f6-82f7-2dcefbcaa273.png#align=left&display=inline&height=132&name=image.png&originHeight=263&originWidth=720&size=137510&status=done&width=360)

 buffer<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560141088506-1ec606d7-0679-4e94-afaf-f485844b2d90.png#align=left&display=inline&height=79&name=image.png&originHeight=158&originWidth=632&size=114027&status=done&width=316)<br />而![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560141100927-9a5ec61f-1aef-49b1-b5cb-72e362ecda63.png#align=left&display=inline&height=33&name=image.png&originHeight=66&originWidth=559&size=62075&status=done&width=279.5)
