# 70.获取线程基本信息的方法

<a name="gp2wd"></a>
## 导问
1. 获取线程基本信息的方法有哪些？
  1. currentThread()返回目前正在执行的线程
  1. getname()返回线程的名称
  1. isAlive()判断线程是否处于活动状态

![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560158694290-e2f1caba-19ab-4289-84c8-e5862e2d980a.png#align=left&display=inline&height=194&name=image.png&originHeight=388&originWidth=777&size=181371&status=done&width=388.5)

主方法也被称之为主线程

![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560158699774-04671bb6-65d5-4035-a467-b9e4fe1f6a37.png#align=left&display=inline&height=32&name=image.png&originHeight=63&originWidth=349&size=20679&status=done&width=174.5)得到当前正在运行的线程对象<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560158748505-3dc2d841-e278-4536-bc0f-98a786345881.png#align=left&display=inline&height=76&name=image.png&originHeight=152&originWidth=648&size=97739&status=done&width=324)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560158756558-6d6d2189-818c-4ebc-8493-5b8f776f1007.png#align=left&display=inline&height=59&name=image.png&originHeight=117&originWidth=343&size=40272&status=done&width=171.5)<br />默认调用toString看看toString<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560158788815-09a01a10-290d-44cd-a29b-a274e726e973.png#align=left&display=inline&height=116&name=image.png&originHeight=232&originWidth=940&size=204742&status=done&width=470)<br />线程名称,线程优先级,线程组<br />因此:<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560158834528-6d88db32-49c7-4389-830e-aec33201e46d.png#align=left&display=inline&height=21&name=image.png&originHeight=42&originWidth=817&size=58542&status=done&width=408.5)

如果自己编写线程类呢?<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560158863182-a6b63647-b42d-4b0f-a889-3a86f4e088e6.png#align=left&display=inline&height=141&name=image.png&originHeight=282&originWidth=765&size=129735&status=done&width=382.5)<br />开始创建对象,代理,让代理启动线程<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560158901476-c49d1a21-c4c4-4332-943d-78853d7f7509.png#align=left&display=inline&height=164&name=image.png&originHeight=327&originWidth=519&size=148777&status=done&width=259.5)<br />可以看到<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560158913741-194867ac-52e7-4a8e-9129-a6fb3ca11efe.png#align=left&display=inline&height=97&name=image.png&originHeight=193&originWidth=470&size=100661&status=done&width=235)<br />THread0,1,2是我们创建的线程对象<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560158978075-c5d57c99-22b7-4a14-92cf-f9baf046915a.png#align=left&display=inline&height=354&name=image.png&originHeight=708&originWidth=1198&size=570998&status=done&width=599)<br />当这个程序进行执行(进程)的时候会有那么多线程<br />CPU执行的是这四个线程,具体哪一个执行是CPU决定的,并不一定是012这个顺序

其实由这个我们还可以推理出来<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560159091488-ad028df1-ea66-4e5b-81f7-9b7e2f1aa901.png#align=left&display=inline&height=19&name=image.png&originHeight=38&originWidth=741&size=44932&status=done&width=370.5)<br />每多创建一个线程,就会对这个线程进行一个相应的编号<br />只有静态变量才能够被线程类所共享

![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560159150246-584065b2-9eb7-4a04-959e-75fe359f637f.png#align=left&display=inline&height=18&name=image.png&originHeight=36&originWidth=720&size=30666&status=done&width=360)<br />加上final,只能被调用,不能被重写<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560159201840-64705be2-8b9b-4f9a-a1e3-61dfa8d4e247.png#align=left&display=inline&height=165&name=image.png&originHeight=329&originWidth=804&size=202929&status=done&width=402)<br />刚刚创造的![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560159236448-67b021f5-5ab0-4a08-a948-ab2c680a2596.png#align=left&display=inline&height=25&name=image.png&originHeight=50&originWidth=172&size=10135&status=done&width=86)名称是什么?<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560159259925-b091a0c7-f7e8-4bbf-b2f2-2a0e18ecc3d3.png#align=left&display=inline&height=48&name=image.png&originHeight=96&originWidth=289&size=38623&status=done&width=144.5)<br />可以看出来:<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560159272681-354d53dc-bdc3-4f43-ac69-02716799ed92.png#align=left&display=inline&height=31&name=image.png&originHeight=62&originWidth=659&size=55726&status=done&width=329.5)<br />这个值用于统计线程的个数,在Thread这个类里,我们可以看到这个静态变量<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560159325600-df95ea6a-9fff-4b81-ac7f-2de6877c077c.png#align=left&display=inline&height=112&name=image.png&originHeight=225&originWidth=721&size=169800&status=done&width=360.5)<br />还有个静态方法<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560159344516-0db6dca5-8743-4e37-b49c-50371b0a5e05.png#align=left&display=inline&height=52&name=image.png&originHeight=103&originWidth=761&size=93805&status=done&width=380.5)<br />当我们每次创建一个Thread对象的时候,里面这个值都会自增

也可以自己定义命名规则<br />Thread里面有个构造方法,可以传入一个String<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560159420731-34414190-d363-40e8-a707-58418b54ca3d.png#align=left&display=inline&height=49&name=image.png&originHeight=98&originWidth=735&size=68565&status=done&width=367.5)<br />我们创建线程的时候就可以通过Thread自身的构造方法去给它定义名称这么写了<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560159448327-d6071556-eeb0-413d-acc1-e31b9ce47402.png#align=left&display=inline&height=135&name=image.png&originHeight=269&originWidth=714&size=199549&status=done&width=357)<br />当然也可以通过setName方法去修改线程名称<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560159508077-91fe4b32-4702-4f79-80e3-fd7bf0358068.png#align=left&display=inline&height=45&name=image.png&originHeight=89&originWidth=615&size=50428&status=done&width=307.5)<br />也可以获得名称<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560159528660-87e26008-4070-45d3-8f59-d63233f62ab8.png#align=left&display=inline&height=39&name=image.png&originHeight=77&originWidth=700&size=62055&status=done&width=350)


![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560159543648-08edfef9-a2fe-4190-9ba5-0e8e08fd0b2f.png#align=left&display=inline&height=50&name=image.png&originHeight=99&originWidth=780&size=41303&status=done&width=390)<br />什么样的线程叫做处于活动状态的呢?<br />自己编写一个Thread类<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560159623338-7f40dd8a-aecb-4135-89c4-340cc92de174.png#align=left&display=inline&height=254&name=image.png&originHeight=507&originWidth=952&size=264175&status=done&width=476)<br /> 编写测试类进行测试线程各个阶段是否处于活动状态<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560159726671-1e6283fe-c841-4da8-978a-4747f8c26d88.png#align=left&display=inline&height=238&name=image.png&originHeight=476&originWidth=990&size=386785&status=done&width=495)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560159738686-43354442-3d6d-4f19-9112-9345437a7e72.png#align=left&display=inline&height=66&name=image.png&originHeight=132&originWidth=571&size=106280&status=done&width=285.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560159747941-dc393535-1803-47bc-b720-914db1e3366b.png#align=left&display=inline&height=38&name=image.png&originHeight=75&originWidth=461&size=28893&status=done&width=230.5)![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560159790131-282472b3-a8cb-407c-8254-ad9c5e2af6c7.png#align=left&display=inline&height=43&name=image.png&originHeight=86&originWidth=376&size=33956&status=done&width=188)<br />前两句判断是肯定的,后面这个得看它和主线程哪个先结束,如果它结束的时候主线程还没结束,那么等到主线程结束的时候它已经死透了,所以是非活动状态,而如果主线程先结束它还没执行完,那么它就仍然处于活动状态<br />完全处于主线程和my线程哪个先结束
