# 76.生产者消费者模式的实现

<a name="z93Jd"></a>
## 导问
1. 简述生产者和消费者模式的原理？ 
  1. 构建一个商品即生产商与消费者的共享资源,然后由生产者与消费者一个从中存数据,一个从中取数据
2. 生产者和消费者模式会导致哪些问题的产生？
  1. 出现了同一线程的资源错乱(此时生产者还没来得及取名就被别的线程抢占了资源)另外一个问题是部分线程抢占了多次资源

![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560167488578-5192ddf6-2af7-41ab-a527-1373a66e26a8.png#align=left&display=inline&height=194&name=image.png&originHeight=388&originWidth=826&size=161498&status=done&width=413)<br />生产者消费者共享的盒子:商品(共享资源的对象)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560167530619-5fb232cb-f4e9-4d49-aa46-e7c8ab63c99c.png#align=left&display=inline&height=150&name=image.png&originHeight=300&originWidth=774&size=153755&status=done&width=387)<br />再生产构造器等<br />然后定义生产者要有共享资源<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560167639071-ac1fc043-bd28-4b7a-b784-9812361e596f.png#align=left&display=inline&height=174&name=image.png&originHeight=348&originWidth=876&size=197988&status=done&width=438)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560167663176-f34303e7-3a2f-4f4d-9c11-5d24d23017a9.png#align=left&display=inline&height=168&name=image.png&originHeight=336&originWidth=595&size=171551&status=done&width=297.5)<br />捕获下异常无论打印了哪个都打印输出<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560167702874-13e580e3-6879-4f6a-be06-531daa549b59.png#align=left&display=inline&height=20&name=image.png&originHeight=40&originWidth=822&size=47818&status=done&width=411)

消费者线程就是从商品中的数据读取出来<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560167756388-705891a1-c00c-4d40-8e27-b843334bd7b5.png#align=left&display=inline&height=137&name=image.png&originHeight=274&originWidth=919&size=191364&status=done&width=459.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560167768999-037ab4a1-dbcd-4d66-afc5-76c672af68e2.png#align=left&display=inline&height=115&name=image.png&originHeight=230&originWidth=957&size=113528&status=done&width=478.5)<br />测试类<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560167791077-2aabd537-9d69-41d1-9b8c-e786066294b5.png#align=left&display=inline&height=230&name=image.png&originHeight=460&originWidth=927&size=307231&status=done&width=463.5)<br />结果产生了数据错乱<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560167822907-3784651e-9c3f-47a9-a91a-331c2ad72b63.png#align=left&display=inline&height=349&name=image.png&originHeight=697&originWidth=620&size=436461&status=done&width=310)<br />分析图<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560167971737-8d55f304-2e9f-4b0d-a688-abe33ddc6cdf.png#align=left&display=inline&height=516&name=image.png&originHeight=1032&originWidth=2369&size=734974&status=done&width=1184.5)可以发现有两个问题,出现了旺仔牌的矿泉水(此时生产者还没来得及取名就被别的线程抢占了资源)另外一个问题是消费者抢占了两次线程,取走了两次<br />我们要的效果是生产者生产一个,消费者取走一个<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560168143037-b3d477ec-004b-4c86-8c72-da39df8d8474.png#align=left&display=inline&height=118&name=image.png&originHeight=235&originWidth=589&size=92235&status=done&width=294.5)即加锁,没赋值结束,让外面等着<br />代码如下<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560168235197-67c82470-c5d5-499b-b22a-fa086109e8d4.png#align=left&display=inline&height=229&name=image.png&originHeight=457&originWidth=1031&size=283994&status=done&width=515.5)<br />只有同步方法里的贷款被执行结束了,后面的语句才能继续执行<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560168271442-9dcad0c8-a0f0-4035-84f1-b8a26818362c.png#align=left&display=inline&height=72&name=image.png&originHeight=144&originWidth=980&size=94058&status=done&width=490)<br />在生产这里我们只需要调用对应的方法即可<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560168325062-ec3ca82b-1fe9-470c-8a0a-b8a487871be9.png#align=left&display=inline&height=218&name=image.png&originHeight=436&originWidth=975&size=224725&status=done&width=487.5)<br />在消费者这里我们也跟着修改对应代码<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560168360992-cbfb90e5-ecb5-40ac-a08b-fed973da4146.png#align=left&display=inline&height=210&name=image.png&originHeight=421&originWidth=790&size=251953&status=done&width=395)<br />同步之后数据不再错乱了<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560168388677-44637c27-cb24-49b0-8659-a57df6cafa0e.png#align=left&display=inline&height=321&name=image.png&originHeight=642&originWidth=812&size=406818&status=done&width=406)<br />但另外一个问题就变得十分明显<br />即重复生产重复取走的问题,这个问题可以通过线程间的通信去解决
