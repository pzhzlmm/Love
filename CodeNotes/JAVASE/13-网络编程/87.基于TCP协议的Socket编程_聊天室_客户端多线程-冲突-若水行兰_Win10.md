# 87.基于TCP协议的Socket编程_聊天室_客户端多线程

<a name="8rmSI"></a>
##  导问
1. 简述客户端与服务器端单次聊天的缺点？ 
  1. 只能客户端先发送数据,然后才能接收数据,如果不发就收不到(因为接收和发送是在同一个线程中实现的),这不符合实际情况
2. 单次聊天的缺点的解决方案是什么？
  1. 多次聊天可以使用循环来解决,先发后收的问题可以使用线程来解决,一个接收数据的线程,一个发送数据的线程,让这两个线程交替执行即可

这次来模拟一个聊天室<br />相比于上次做的发送信息的问题是发送一次请求程序就结束,聊天应该是连续的,多条的,而且不发送数据就没办法接收到数据,即

<a name="WrX1R"></a>
### 单次聊天的缺点
只能客户端先发送数据,然后才能接收数据,如果不发就收不到(因为接收和发送是在同一个线程中实现的),这不符合实际情况

<a name="thu8J"></a>
### 解决方案
多次聊天可以使用循环来解决,先发后收的问题可以使用线程来解决,一个接收数据的线程,一个发送数据的线程,让这两个线程交替执行即可


先写客户端<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560237608002-59c005af-30c9-4c2d-97f9-757a4449264f.png#align=left&display=inline&height=313&name=image.png&originHeight=625&originWidth=1184&size=537699&status=done&width=592)<br />先辨认清楚哪些是发送信息的代码,哪些是接收信息的代码,然后分别把它放到两个线程类之中<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560237695098-0fc19de1-26e0-488b-b3e1-3b986e81ca6f.png#align=left&display=inline&height=240&name=image.png&originHeight=479&originWidth=1197&size=439721&status=done&width=598.5)<br />把它放在发送的线程之中<br />创建一个send类,让它具备发数据的能力<br />把这些数据剪贴,然后放到发送的代码之中<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560237798513-b74c947c-6629-43de-bab7-994c27f23f20.png#align=left&display=inline&height=263&name=image.png&originHeight=526&originWidth=1197&size=375112&status=done&width=598.5)<br />然后通过构造方法对这两个流进行初始化,即<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560237991549-a261e082-7ac3-4c42-9d3f-56f9f7246c9f.png#align=left&display=inline&height=306&name=image.png&originHeight=612&originWidth=1038&size=440494&status=done&width=519)<br />异常处理下<br />如果线程出错了,就标注为false,默认为true<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560238055380-f7200c88-43b9-40d6-bdec-288bf5110317.png#align=left&display=inline&height=79&name=image.png&originHeight=157&originWidth=695&size=99694&status=done&width=347.5)<br />调用本类的无参构造方法<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560238081371-2a541267-5655-4dfe-a499-a3cc9dfa33c9.png#align=left&display=inline&height=178&name=image.png&originHeight=356&originWidth=954&size=224693&status=done&width=477)<br />开始编写从键盘获取数据的方法<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560238159103-58943f53-e39f-4722-977f-cb8de66b1be7.png#align=left&display=inline&height=57&name=image.png&originHeight=114&originWidth=497&size=63720&status=done&width=248.5)<br />读到的数据赋值给一个字符串类型的变量,然将其返回<br />处理异常,如果出错的话,flag标注为false,并将流进行关闭<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560238213425-9bc4cf66-6b41-46bf-a9f8-54c5fe2cd24d.png#align=left&display=inline&height=150&name=image.png&originHeight=300&originWidth=511&size=132779&status=done&width=255.5)<br />看下关闭的工具类<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560238240477-e4ba96d1-e11a-488d-b938-5e67cc7c98fd.png#align=left&display=inline&height=288&name=image.png&originHeight=576&originWidth=896&size=279195&status=done&width=448)<br />这里使用了可变参数,如果传进来的不为空就关闭<br />再编写一个发送信息的方法<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560238372869-83a6682a-3ec9-4682-a078-f2357895a507.png#align=left&display=inline&height=122&name=image.png&originHeight=243&originWidth=638&size=108463&status=done&width=319)<br />传进来的字符串是什么就发送什么,产生异常flag标注为flase,然后把流给关闭<br />前面的构造方法也对应的进行下修改<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560238461846-0b999fe5-91b5-418a-acb1-f62683cf46fa.png#align=left&display=inline&height=185&name=image.png&originHeight=370&originWidth=684&size=206169&status=done&width=342)<br />发送数据的时候写一句清空缓存<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560238518795-17c50efb-8313-4f7e-af56-17d244e5b5e0.png#align=left&display=inline&height=139&name=image.png&originHeight=278&originWidth=644&size=121336&status=done&width=322)<br />在run方法之中循环去调用发送信息的方法<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560238558186-4eb9e721-dd79-4272-9b6d-3baec6aec7ec.png#align=left&display=inline&height=83&name=image.png&originHeight=165&originWidth=563&size=77981&status=done&width=281.5)<br />发送的线程就写好了

接收线程<br />现在开始写接收的线程<br />首先把接收的数据剪走<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560238653087-d2281d56-c9f1-4a25-b735-361c9e6471d6.png#align=left&display=inline&height=216&name=image.png&originHeight=431&originWidth=1139&size=315485&status=done&width=569.5)

并使其具备多线程的能力<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560238686942-8dd7ac4e-f1d0-4a80-87e6-dede10af80cd.png#align=left&display=inline&height=223&name=image.png&originHeight=446&originWidth=1203&size=283141&status=done&width=601.5)<br />并在构造方法之中进行初始化,其他处理如上(产生异常将其关闭,并将flag置为false)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560238754292-8f882373-9630-4215-bab6-6338931ace2b.png#align=left&display=inline&height=250&name=image.png&originHeight=500&originWidth=973&size=357010&status=done&width=486.5)<br />再编写一个接收数据的方法,接收来自服务器的数据,并将其返回,其他处理如上(产生异常将其关闭,并将flag置为false)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560238893798-33ac3718-ca4b-410f-bda5-d47e5f026bd6.png#align=left&display=inline&height=156&name=image.png&originHeight=312&originWidth=593&size=133292&status=done&width=296.5)<br />在run方法中循环调用接收数据的方法<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560238920564-cae8219e-069e-4ce0-a923-528599d098e7.png#align=left&display=inline&height=84&name=image.png&originHeight=167&originWidth=779&size=74958&status=done&width=389.5)<br />flag为true的时候就循环输出

最后修改Client类<br />删除<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560238971502-c5f3bbb8-20a4-4735-9db2-efc061953e79.png#align=left&display=inline&height=278&name=image.png&originHeight=555&originWidth=864&size=332996&status=done&width=432)<br />只需要<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560239034214-499dab55-a980-45ac-ac09-b28082ab61b2.png#align=left&display=inline&height=114&name=image.png&originHeight=227&originWidth=610&size=158801&status=done&width=305)<br /> <br />然后修改服务器端的数据<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560239109313-cc792621-2f06-4cbb-9faa-cd8cf7eb0a8c.png#align=left&display=inline&height=233&name=image.png&originHeight=466&originWidth=1194&size=464678&status=done&width=597)<br />使用个循环<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560239163461-8c302813-558c-4303-8762-2ad8d7cd3fb6.png#align=left&display=inline&height=293&name=image.png&originHeight=586&originWidth=1171&size=523360&status=done&width=585.5)<br />然后就可以不断地向服务器端发送数据了<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560239206338-f0059ee2-9916-4e36-8a06-51bb661a165e.png#align=left&display=inline&height=345&name=image.png&originHeight=690&originWidth=623&size=352847&status=done&width=311.5)<br />服务器端也都收到了<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560239223973-151ad493-ced1-4943-9604-11a3e9b28c60.png#align=left&display=inline&height=99&name=image.png&originHeight=198&originWidth=836&size=114890&status=done&width=418)
