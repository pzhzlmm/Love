# 88.基于TCP协议的Socket编程_聊天室_群聊

<a name="T0QhF"></a>
## 导问
1. 简述实现群聊的原理？
  1. 每个客户端都是一条 独立的路径,服务器端将接收某个客户端的数据并将它发送给其他的客户端
2. 简述群聊实现的步骤？
  1. 编写输入流
  1. 编写输出流
  1. 接收数据  
  1. 发送数据

服务器端要接收某个客户端的数据将发送的数据发送给其他客户端<br />每个客户端都是一条路径<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560239440573-69f9573b-faaa-44cc-86df-d69c55ddec8f.png#align=left&display=inline&height=209&name=image.png&originHeight=330&originWidth=767&size=91782&status=done&width=486)<br />这里有三个客户端就是三条路径,每个路径都是一个线程<br />所以可以在服务器端编写一个线程类
<a name="rJxS0"></a>
### 实现步骤
1.编写输入流<br />2.编写输出流<br />3.接收数据 <br />4.发送数据<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560239560019-a7c40cf7-dfad-4a2a-b26e-6586ee538934.png#align=left&display=inline&height=206&name=image.png&originHeight=412&originWidth=1001&size=291649&status=done&width=500.5)<br />接收数据,发送数据<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560239583437-54e75b84-3a4b-44cc-9d2f-0f9e8786ebe0.png#align=left&display=inline&height=34&name=image.png&originHeight=67&originWidth=508&size=54995&status=done&width=254)<br />构造方法中初始化<br />从管道中获取输入输出对象(添加下异常处理)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560239625019-52c0b383-6c5e-49bf-9c22-ec94693f9ca0.png#align=left&display=inline&height=61&name=image.png&originHeight=122&originWidth=838&size=133128&status=done&width=419)<br />一个程序出错了其他的还要允许,如是写个布尔类型的变量,默认为true<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560239680139-8f4bf94f-929d-4b7d-a0c5-8f20d10eb743.png#align=left&display=inline&height=12&name=image.png&originHeight=24&originWidth=436&size=19148&status=done&width=218)<br />如果出错就返回false并关闭<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560239717221-aa100fa9-4c68-476b-9420-d5b67fc6af7b.png#align=left&display=inline&height=229&name=image.png&originHeight=458&originWidth=996&size=313411&status=done&width=498)<br />接收数据<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560239746331-69134584-4f5e-4ec7-8db9-977af7b8cb02.png#align=left&display=inline&height=165&name=image.png&originHeight=329&originWidth=600&size=135577&status=done&width=300)<br />发送数据<br />接收到什么就把什么发送回去<br />将得到的字符串发出<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560239803723-95f59857-8148-4db0-9bfb-97e2181e0c97.png#align=left&display=inline&height=154&name=image.png&originHeight=308&originWidth=703&size=165770&status=done&width=351.5)<br />编写run方法<br />只需要写接收数据与发送数据就可以了<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560239851614-3e3d2bb4-b171-40ae-8a0b-34d7e4622462.png#align=left&display=inline&height=97&name=image.png&originHeight=194&originWidth=512&size=68621&status=done&width=256)

修改Sever<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560239884092-f10ebf03-dce8-4867-8c92-91d120f58b35.png#align=left&display=inline&height=257&name=image.png&originHeight=513&originWidth=1239&size=514928&status=done&width=619.5)<br />这两句就用不到了,已经写到线程类之中了<br />循环  接收每个socket对象,并创造线程启动线程<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560239994455-dd0caf4d-6507-45c2-9dec-1e8dd521a527.png#align=left&display=inline&height=295&name=image.png&originHeight=590&originWidth=981&size=445514&status=done&width=490.5)<br />效果<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560240032895-a7707612-419a-4fd4-99f0-a4b5fd4741eb.png#align=left&display=inline&height=101&name=image.png&originHeight=201&originWidth=217&size=40004&status=done&width=108.5)<br />发一个返一个<br />此时已经实现一个客户端与服务器端通信,现在要做的是向其他客户端转发<br />转发的时候是不转发给自己的<br />每个客户端都是一个路径,当创建线程类对象每新建一个线程类就说明一个客户端进来了,就把它添加到集合之中,然后遍历这个集合,给这个集合中每个对象进行转发<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560240201577-5af9d81d-5e37-4b38-92c3-3d9997bdfe61.png#align=left&display=inline&height=140&name=image.png&originHeight=280&originWidth=737&size=190587&status=done&width=368.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560240221603-51efa900-fe27-4ab2-a05b-349d4d1d1c9a.png#align=left&display=inline&height=18&name=image.png&originHeight=36&originWidth=967&size=59501&status=done&width=483.5)<br />就用这个去存储每一个客户端<br />每次创建了一个线程类,就把它添加到线程类之中<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560240290778-5fd5fde4-76b9-414d-afcc-df584bc6fc14.png#align=left&display=inline&height=305&name=image.png&originHeight=610&originWidth=1145&size=507977&status=done&width=572.5)<br />现在修改线程类![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560240317938-c2aa3cdc-c7a1-49f4-8053-56fcd6753982.png#align=left&display=inline&height=22&name=image.png&originHeight=44&originWidth=145&size=10709&status=done&width=72.5)<br />只要这个线程出错,就把这个线程进行移除<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560240374250-08f5d014-eca2-415c-9c5f-fdea23f379bf.png#align=left&display=inline&height=272&name=image.png&originHeight=543&originWidth=740&size=258992&status=done&width=370)<br />接着编写转发的方法<br />将接收到的信息进行转发<br />于是要去遍历这个集合,如果不是自己就转发<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560240451191-f81f25c7-6b91-4976-90e0-9133bc19dab7.png#align=left&display=inline&height=146&name=image.png&originHeight=292&originWidth=582&size=163428&status=done&width=291)<br />在run方法中<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560240522692-2e21d96a-41a8-4278-b193-f9251002aa5b.png#align=left&display=inline&height=114&name=image.png&originHeight=228&originWidth=543&size=86148&status=done&width=271.5)<br />效果<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560240557115-576469b9-031d-4f25-9102-af2dafd7c8e4.png#align=left&display=inline&height=62&name=image.png&originHeight=123&originWidth=207&size=25839&status=done&width=103.5)<br />一个客户端发送数据,由服务器端进行转发<br />客户端编写了接收和发送,服务器端有MyChanel线程类,每个客户端都是一条路径,它进来就把它添加进集合,然后进行转发就可以了<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560240647645-0b69ac88-5646-466f-92d9-106413f078a4.png#align=left&display=inline&height=201&name=image.png&originHeight=402&originWidth=295&size=115441&status=done&width=147.5)


