# 86.基于TCP协议的Socket编程_双向通信_实现模拟用户登录

<a name="bMf6S"></a>
## 导问
1. 请你画出双向通信用户登录的示意图？
  1. ![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560427771490-3f5dc7c9-ce70-4a23-a993-dbb8c945edbd.png#align=left&display=inline&height=256&name=image.png&originHeight=511&originWidth=1000&size=39327&status=done&width=500)
2. 简述用户登录的过程客户端与服务器的功能？
  1. 使用对象流ObjectOutputStream,将账户密码封装成用户对象发送用户对象到服务器端
  1. 发送对象,需要用到对象流,客户端得编写对象叫做User
  1. 要再网络中传输必须实现一个叫serverlization的接口才具备传对象的能力,即序列化的能力
  1. 客户端发送的是用户对象,响应的服务器端接收到的也是用户对象,使用ObjectInputStream去接收
  1. 其实反序列化,对输入的账号与密码进行验证
  1. 把验证的结果发回客户端作为响应,即一个成功或失败的字符串,字符串可以使用数据流去发送
  1. 服务器端用DataOutputStream去响应,相应的客户端也会用DataInputStream去接收

(1)  简述用户登录的过程客户端与服务器的功能？ <br />客户端；实现了把用户名和密码封装到对象中，发送到服务器端进行验证。<br />服务端；接收从客户端发送来的user对象，获取用户的密码和用户名，判断是否正确，并把结果发送过去。


模拟用户登录分析<br />使用对象流ObjectOutputStream,将账户密码封装成用户对象发送用户对象到服务器端<br />发送对象,需要用到对象流,客户端得编写对象叫做User<br />要再网络中传输必须实现一个叫serverlization的接口才具备传对象的能力,即序列化的能力<br />客户端发送的是用户对象,响应的服务器端接收到的也是用户对象,使用ObjectInputStream去接收<br />其实反序列化,对输入的账号与密码进行验证<br />把验证的结果发回客户端作为响应,即一个成功或失败的字符串,字符串可以使用数据流去发送<br />服务器端用DataOutputStream去响应,相应的客户端也会用DataInputStream去接收<br />这就是一次完整的请求与相应过程<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560234286496-cd9d043b-a78c-40db-bb62-48ef8542d0fb.png#align=left&display=inline&height=271&name=image.png&originHeight=542&originWidth=1191&size=308744&status=done&width=595.5)

实现<br />User类<br />首先创建一个包,然后创建一个用户类,为具备传输的能力,必须实现serializable接口<br />私有属性编写公有的取值赋值方法,带参无参构造<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560234409500-ea77d768-02fe-4866-887a-37a08a149542.png#align=left&display=inline&height=202&name=image.png&originHeight=403&originWidth=983&size=288363&status=done&width=491.5)<br />同时还要编写一个user类的序列化编号<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560234441456-0a461fd6-f709-4513-9344-3cb9fde00d28.png#align=left&display=inline&height=25&name=image.png&originHeight=49&originWidth=1038&size=55979&status=done&width=519)

客户端<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560234656026-fa631053-30a3-4e70-9cb7-e78ce0719599.png#align=left&display=inline&height=143&name=image.png&originHeight=285&originWidth=674&size=146745&status=done&width=337)<br />2.传输的是一个对象,因此是对象流<br />3.发送登录的对象是谁?创建User对象<br />5.服务器接收到我发送的会给我相应结果,即获取输入流,用数据流获取正确或者失败<br />代码<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560234684804-26894302-721e-45ca-9715-2d810b265a51.png#align=left&display=inline&height=34&name=image.png&originHeight=67&originWidth=688&size=65590&status=done&width=344)<br />需要对字节流进行包装,获取字节的输出流,包装成我们的对象流<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560234784280-592eae68-6b99-4c75-b1b4-da63fe33191f.png#align=left&display=inline&height=34&name=image.png&originHeight=68&originWidth=1091&size=100112&status=done&width=545.5)<br />创建User对象<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560234808415-6b144fd3-a06a-4deb-8857-37fc234ed163.png#align=left&display=inline&height=30&name=image.png&originHeight=59&originWidth=537&size=41060&status=done&width=268.5)<br />发送<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560234871434-6e674585-ce18-4a43-aae2-4b5c8a3a5ad1.png#align=left&display=inline&height=30&name=image.png&originHeight=59&originWidth=343&size=39958&status=done&width=171.5)<br />向上发送的时候进行向上类型转换成了object类型<br />发送完毕获取输入流获取服务器端的相应结果,需要对我们的字节流进行包装,包装成数据流<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560234959488-c87fbb48-4f16-4a97-b6f6-20944b0f54b1.png#align=left&display=inline&height=36&name=image.png&originHeight=71&originWidth=995&size=74674&status=done&width=497.5)<br />将收到的结果进行显示输出<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560234974591-b0a97b6b-5e6d-4afa-96fc-e01c869584be.png#align=left&display=inline&height=19&name=image.png&originHeight=38&originWidth=528&size=41425&status=done&width=264)<br />最后关闭流<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560235004976-2e27751d-d409-4e29-9d7a-552fc1aa586e.png#align=left&display=inline&height=141&name=image.png&originHeight=282&originWidth=396&size=100538&status=done&width=198)<br />然后将IO异常抛出

服务器端<br />客户端往服务器端发送的是一个User对象,序列化,那么服务器端就需要反序列化<br />所以我先创建一个包,这个包的包名要求和客户端实体的包名保持一致<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560235125037-d644b8c2-419f-4926-9950-55cc6f51e6c4.png#align=left&display=inline&height=136&name=image.png&originHeight=271&originWidth=288&size=74832&status=done&width=144)<br />实体类叫User,去复制粘贴进去<br />然后分析服务器端代码<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560235268047-c6509844-b973-4f51-9355-ed72cfe91c6e.png#align=left&display=inline&height=95&name=image.png&originHeight=190&originWidth=374&size=91777&status=done&width=187)<br />2.获取客户端发送给我们的客户端对象<br />4.将结果发回给用户<br />编写<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560235356568-5eff7dcc-5e44-4777-8335-09ef2aef5d44.png#align=left&display=inline&height=32&name=image.png&originHeight=63&originWidth=687&size=68730&status=done&width=343.5)<br />刚刚写的10000,所以也要用10000去监听<br />时刻监听是否有客户端发来连接请求,所以监听的是一个socket对象<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560235495514-e645b52f-c53c-49ef-bcdf-68ba2bfe2416.png#align=left&display=inline&height=20&name=image.png&originHeight=39&originWidth=455&size=36788&status=done&width=227.5)<br />发送过来的是一个User对象<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560235660953-2419398d-a2c6-4618-8cbe-883647d75a75.png#align=left&display=inline&height=29&name=image.png&originHeight=57&originWidth=1020&size=81520&status=done&width=510)<br />对socket里的字节输入流进行包装<br />得到的是一个对象,在读的时候需要向下类型转换,转成真实的User类型<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560235633388-db73e139-530b-4297-b2f6-fd96bdada0f1.png#align=left&display=inline&height=20&name=image.png&originHeight=40&originWidth=504&size=37692&status=done&width=252)<br />写个字符串Str<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560235738291-5abca213-f012-40d5-8758-5c44f7327278.png#align=left&display=inline&height=62&name=image.png&originHeight=123&originWidth=1069&size=116780&status=done&width=534.5)<br />开始验证<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560235752643-0036d750-1d11-48ba-8f64-565a4ba9e5b9.png#align=left&display=inline&height=90&name=image.png&originHeight=179&originWidth=1108&size=135120&status=done&width=554)<br />把结果发回给客户端,使用数据流发回,期间对字节输出流进行了包装<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560235849998-aef71ed2-0424-46af-adec-8ec2924734fc.png#align=left&display=inline&height=46&name=image.png&originHeight=92&originWidth=1048&size=105520&status=done&width=524)<br />将结果发回<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560235894586-8c82cc89-261d-478d-8f6f-9932aa2b6d37.png#align=left&display=inline&height=18&name=image.png&originHeight=36&originWidth=293&size=20552&status=done&width=146.5)<br />关闭流<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560235919903-c57ce58a-1b67-48a4-9f01-cb899af88a77.png#align=left&display=inline&height=155&name=image.png&originHeight=310&originWidth=322&size=100087&status=done&width=161)<br />IO异常,进行抛出<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560235957574-d349e5ad-73f2-428f-b758-d51d48d9f50b.png#align=left&display=inline&height=46&name=image.png&originHeight=92&originWidth=763&size=69385&status=done&width=381.5)<br />发现异常<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560235970217-c370b17c-a0a8-490a-b7f5-88cba9409029.png#align=left&display=inline&height=50&name=image.png&originHeight=100&originWidth=1117&size=142820&status=done&width=558.5)<br />发现端口已经被占用,那就换一个端口

优化<br />登录成功,此刻我们可以在服务端写个登录成功的代码<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560236062994-370b5c3a-0801-450b-9fd6-a472c777774d.png#align=left&display=inline&height=101&name=image.png&originHeight=201&originWidth=1071&size=204914&status=done&width=535.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560236082025-a8a35a14-e3b4-4b99-8bd1-c1d9963ec3b7.png#align=left&display=inline&height=23&name=image.png&originHeight=46&originWidth=1126&size=73944&status=done&width=563)<br />而客户端可以使用键盘录入<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560236165253-70342e72-071a-476e-9d16-2bff313b4b05.png#align=left&display=inline&height=153&name=image.png&originHeight=305&originWidth=616&size=221831&status=done&width=308)<br />然后再客户端去调用getUser()方法<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560236209308-b3415cb7-53ef-417b-a59b-294590e6924b.png#align=left&display=inline&height=161&name=image.png&originHeight=322&originWidth=825&size=251892&status=done&width=412.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560236222866-9058e25b-fcad-43f8-84a9-215e73026d33.png#align=left&display=inline&height=18&name=image.png&originHeight=36&originWidth=327&size=19152&status=done&width=163.5)<br />服务器端完整版<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560236399719-e660f1e2-d4f3-4465-85d1-5f529c87c152.png#align=left&display=inline&height=607&name=image.png&originHeight=1213&originWidth=2552&size=1568792&status=done&width=1276)


效果

![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560236235849-5235dcce-ee63-4e40-98a7-1b80a051a4d4.png#align=left&display=inline&height=116&name=image.png&originHeight=231&originWidth=282&size=57390&status=done&width=141)![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560236250487-7ba6d7a8-b2e7-4d6d-b3a3-b241d1102c38.png#align=left&display=inline&height=70&name=image.png&originHeight=140&originWidth=698&size=93896&status=done&width=349)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560236263941-b16ca371-00bd-4da8-9e7d-d2ec5cd915a1.png#align=left&display=inline&height=114&name=image.png&originHeight=227&originWidth=193&size=45335&status=done&width=96.5)![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560236270974-8756b6ae-843d-466e-a964-94222fb3ed34.png#align=left&display=inline&height=59&name=image.png&originHeight=119&originWidth=908&size=116886&status=done&width=454)

实现多用户登录<br />哪些代码是每个客户端都需要完成的带代码<br />从获取输入流,到做出响应,这些是每个客户端都需要操作的代码,想要提高效率就在这里使用多线程<br />即把2获取输入流-发送客户端的相应结果整段代码捡走,放到线程操作类当中<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560236571264-52eb5797-080f-4234-8ba2-03adea4390e3.png#align=left&display=inline&height=130&name=image.png&originHeight=260&originWidth=1348&size=226747&status=done&width=674)<br />创建一个包叫Thread,去实现Runnable接口,把刚刚剪切的代码放在run方法之中,因为这是每一个客户端都需要执行的代码<br />这里提示需要一个Socket对象,这个成员变量的值可以通过构造方法传入<br />通过构造方法,将局部变量的值赋给成员变量<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560236755099-e3d4393a-c35d-4c59-8582-71780be10479.png#align=left&display=inline&height=144&name=image.png&originHeight=288&originWidth=825&size=206479&status=done&width=412.5)<br />报IO异常,因为我们run方法中有异常必须自己处理<br />选中代码,到关闭之前trycatch<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560236835639-bad9d0d7-5b76-4395-9c55-129c68199948.png#align=left&display=inline&height=364&name=image.png&originHeight=727&originWidth=1060&size=503160&status=done&width=530),<br />无论程序是否产生异常都要关闭流的代码放finally之中<br />关闭的时候有异常,继续trycatch<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560236907176-09eb47b1-6989-4892-adf3-54219acb04a4.png#align=left&display=inline&height=246&name=image.png&originHeight=491&originWidth=836&size=213903&status=done&width=418)<br />变量尚未初始化,赋空值<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560236933623-152c8e3d-95f9-4ba4-870b-0d05870cdedf.png#align=left&display=inline&height=166&name=image.png&originHeight=331&originWidth=791&size=206922&status=done&width=395.5)

这样线程类就写完了,在服务器端只需要启动线程就可以了<br />把监听到的socket对象传入就可以了<br />然后调start方法启动就可以了<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560237086669-9a0845df-c1d4-4d74-976a-498fc84e7465.png#align=left&display=inline&height=344&name=image.png&originHeight=688&originWidth=1097&size=522701&status=done&width=548.5)<br />线程类加一句话<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560237130674-ded71c6d-a7a0-4e19-9407-a52a386ebea4.png#align=left&display=inline&height=117&name=image.png&originHeight=233&originWidth=1069&size=180216&status=done&width=534.5)<br />这样就知道是第几个线程请求的登录了<br />然后启动服务器端,多启动几个客户端<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560237183991-cf868337-ef2e-470c-a378-a8b6205a012a.png#align=left&display=inline&height=106&name=image.png&originHeight=211&originWidth=229&size=47093&status=done&width=114.5)![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560237207617-48fbc97a-9acb-453b-9190-0fcbc4ae8edb.png#align=left&display=inline&height=120&name=image.png&originHeight=240&originWidth=330&size=64389&status=done&width=165)![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560237219616-9922d5e2-2e5d-499e-a436-913cebd0e63a.png#align=left&display=inline&height=112&name=image.png&originHeight=224&originWidth=312&size=57212&status=done&width=156)![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560237198812-36078da9-acc0-4afa-aefd-56bd0c2f2b82.png#align=left&display=inline&height=133&name=image.png&originHeight=265&originWidth=1172&size=285385&status=done&width=586)<br />服务器端画风<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560237233853-7883bd25-7128-42bf-8bfc-ce969eba3ccc.png#align=left&display=inline&height=177&name=image.png&originHeight=354&originWidth=1052&size=260312&status=done&width=526)
