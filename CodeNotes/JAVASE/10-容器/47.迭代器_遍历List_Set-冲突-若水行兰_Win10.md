# 47.迭代器_遍历List_Set


1. 迭代器的由来是什么？
  1. 像Collection里有不同类型的容器,他们都需要读取,,但其存储方式结构都各不相同,于是把他们功能相同但具体实现方式不同的抽取出来为一个接口,Collection继承了这个接口,即Iterator,Iterator接口中的iterator方法可以对其进行读取
2. 使用迭代器遍历集合的原理是什么？    
  1. 获取迭代器,并定义个指针,在起始位置。
  1. 边读取边把指针往后移动,并使用循环判断判断是否读到末尾有没有下一个元素(即指针指向的值是否和其长度相同)
  1. 如果有下一个元素就获取，没有就结束循环。

主要使用迭代器去遍历List和Set集合

迭代器的由来<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560062627264-11bb72c9-41e3-4ed7-901f-ac78e6222bd0.png#align=left&display=inline&height=91&name=image.png&originHeight=181&originWidth=287&size=60039&status=done&width=143.5)![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560062640394-7f9f1df5-e1aa-489d-9c33-44fed04a4572.png#align=left&display=inline&height=47&name=image.png&originHeight=94&originWidth=522&size=45021&status=done&width=261)<br />继承了接口<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560062663898-d57aa095-21b0-4d7e-a57e-7f09374f9179.png#align=left&display=inline&height=38&name=image.png&originHeight=75&originWidth=805&size=71180&status=done&width=402.5)<br />其中有个方法<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560062682090-ffd121aa-d2c7-4052-9103-ad6deeea3001.png#align=left&display=inline&height=186&name=image.png&originHeight=372&originWidth=577&size=183512&status=done&width=288.5)<br />所以Collection就继承了Iterator中的iterator

每种元素都有判断取出的功能<br />每一集合底层数据结构又不尽相同<br />他们判断和取出的方式也不尽相同<br />于是把他们功能相同但是实现不同的部分一同提取出一个接口<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560062983730-cafe0d3c-dc67-4818-8258-6317b2c12281.png#align=left&display=inline&height=294&name=image.png&originHeight=587&originWidth=1459&size=290249&status=done&width=729.5)<br />于是每个接口都有Iterator方法,然后每个集合再分别去实现这个方法就OK了<br />而内部类访问外部的私有属性更加方便,所以我们Iterator接口是在集合的内部,以内部内的方式实现的<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560063147679-ff99424e-10a0-42a5-a364-ee98644d95e7.png#align=left&display=inline&height=52&name=image.png&originHeight=104&originWidth=753&size=67869&status=done&width=376.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560063175967-91de04df-01e2-443a-9307-93cd4e0c2d74.png#align=left&display=inline&height=55&name=image.png&originHeight=109&originWidth=603&size=49329&status=done&width=301.5)<br />返回的是iterator的一个实现类对象<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560063272347-d1ec3b18-da11-4ebc-9c29-4b4e3f95cbc8.png#align=left&display=inline&height=133&name=image.png&originHeight=266&originWidth=842&size=220270&status=done&width=421)<br />而在这个内部类中还有判断元素和取元素的方法<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560063315507-4455a45b-dc8a-4113-bee0-33e4293c9c78.png#align=left&display=inline&height=307&name=image.png&originHeight=613&originWidth=836&size=373016&status=done&width=418)

cursor:指针,返回的是下一个元素的索引<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560063380121-01256d30-9f5b-471f-8435-4578eacc5bcb.png#align=left&display=inline&height=21&name=image.png&originHeight=41&originWidth=809&size=46245&status=done&width=404.5)<br />第一次的时候在起始位置<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560063473069-05e355c2-d05e-4a3e-b418-3144172d8222.png#align=left&display=inline&height=247&name=image.png&originHeight=494&originWidth=1205&size=105799&status=done&width=602.5)<br />返回的是最后一个元素的索引<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560063497207-cdd861ba-de8e-4925-a43d-645b7f88ab4b.png#align=left&display=inline&height=15&name=image.png&originHeight=30&originWidth=1013&size=43945&status=done&width=506.5)<br />也就是说没有元素的话它返回的是-1<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560063559968-98c129b3-c559-4232-9fdd-9d76ffd4dcf5.png#align=left&display=inline&height=21&name=image.png&originHeight=41&originWidth=521&size=27330&status=done&width=260.5)这句代码不看<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560063576598-eab2d06b-5a6a-49f0-9526-3b1c37147559.png#align=left&display=inline&height=28&name=image.png&originHeight=56&originWidth=163&size=9988&status=done&width=81.5)Itr中的一个构造方法<br />接下来看下判断方法<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560063616559-f5fa70cf-e91d-431b-a34e-1153be2f1156.png#align=left&display=inline&height=52&name=image.png&originHeight=104&originWidth=446&size=35734&status=done&width=223)

所以if判断都删除,源码<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560064747229-f61c20cf-2359-4256-8eff-8e891cbebfe1.png#align=left&display=inline&height=155&name=image.png&originHeight=310&originWidth=872&size=133594&status=done&width=436)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560064804231-35923e11-c083-4b7c-9efa-7f2064645edf.png#align=left&display=inline&height=331&name=image.png&originHeight=662&originWidth=1539&size=190916&status=done&width=769.5)

用迭代器取出数组中元素的方法<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560064863713-993a82df-a835-4009-9abb-4974b4a0563d.png#align=left&display=inline&height=71&name=image.png&originHeight=141&originWidth=597&size=83607&status=done&width=298.5)<br />hashSet和ArrayList同样<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560064968839-9d2bc161-398d-4419-b871-6ebff06f1bed.png#align=left&display=inline&height=270&name=image.png&originHeight=539&originWidth=689&size=318193&status=done&width=344.5)
