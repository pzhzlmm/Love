# 44.TreeSet的使用_JDK源码分析

1. TreeSet的底层数据结构是什么？在存储自定义元素时是通过什么方式去掉重复元素的？
  1. 红黑树；通过TreeMap里要求使用的比较器（自定义的内部比较器或者外部比较器）来去掉重复元素的
2. TreeSet集合的特点？
  1. 唯一，有序，升序，底层数据结构为红黑树，如果使用自定义对象作为key就要求具备比较规则

![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559994695755-ba1d6fd7-23ee-4bab-a2c2-7a908cd888de.png#align=left&display=inline&height=157&name=image.png&originHeight=313&originWidth=777&size=148932&status=done&width=388.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559994668802-d9aec2a4-29f6-4112-bd3b-69712fe054c6.png#align=left&display=inline&height=133&name=image.png&originHeight=265&originWidth=786&size=196057&status=done&width=393)<br />定义了个Person类与测试类（重写了tostring）<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559994831164-8149fc68-6b0c-4f28-9123-121e85b1045f.png#align=left&display=inline&height=228&name=image.png&originHeight=456&originWidth=818&size=326591&status=done&width=409)<br />程序报错<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559994898464-7e984ac1-ab76-49c2-ba7a-f3c0f595e07e.png#align=left&display=inline&height=48&name=image.png&originHeight=96&originWidth=2265&size=252003&status=done&width=1132.5)<br />Comparable是一个内部比较器<br />因为这里面即有string，又有int，不知道按哪个进行比较因而没办法进行比较<br />因此就要在这里进行添加内部比较器或者外部比较器

添加内部比较器<br />让Person类去实现Comparable接口，让它具备比较大小的能力<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559995099300-6f20896c-4c07-4838-a5bd-d8783c614c7e.png#align=left&display=inline&height=41&name=image.png&originHeight=81&originWidth=727&size=78072&status=done&width=363.5)<br />实现接口必须去实现接口中的方法<br />重写比较规则<br />首先向下类型转换<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559995145469-ef414126-b69d-4623-a370-4c643857394d.png#align=left&display=inline&height=95&name=image.png&originHeight=190&originWidth=655&size=87506&status=done&width=327.5)<br />此时程序运行正常<br />但如果年龄相等，就不添加了<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559995200564-785fb833-cc38-4d38-9b31-302963378283.png#align=left&display=inline&height=207&name=image.png&originHeight=413&originWidth=1397&size=379164&status=done&width=698.5)<br />因为它发现集合里已经有年龄是20的了

外部比较器<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559995304792-bdd2ae05-65a7-4027-aba2-5875355307b4.png#align=left&display=inline&height=123&name=image.png&originHeight=246&originWidth=843&size=174332&status=done&width=421.5)<br />与你提供的类无关，我只负责比较大小<br />在这里只负责对这两个对象进行比较<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559995371762-5d0c181c-d6d7-4b00-bb2d-bc50c762db08.png#align=left&display=inline&height=79&name=image.png&originHeight=158&originWidth=765&size=146660&status=done&width=382.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559995413722-eb5d9823-7363-4690-96c6-8148ad7991b8.png#align=left&display=inline&height=25&name=image.png&originHeight=50&originWidth=789&size=64781&status=done&width=394.5)<br />可以使用多态的形式，即左边的接口类型<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559995445574-f2d5c2b9-c6fd-4265-ab98-9a5e99325efd.png#align=left&display=inline&height=20&name=image.png&originHeight=40&originWidth=799&size=58394&status=done&width=399.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559995475645-2291eec1-f4ae-40b2-9af4-45b2bf9622cc.png#align=left&display=inline&height=20&name=image.png&originHeight=40&originWidth=483&size=39721&status=done&width=241.5)<br />这时候重新运行<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559995518148-e035f62b-f073-410e-acc6-3f9a92965939.png#align=left&display=inline&height=278&name=image.png&originHeight=555&originWidth=1290&size=423021&status=done&width=645)<br />发现年龄20的marry没有添加进去（因为里面已经有个marry了）<br />此时要么是年龄添加不进去，要么是因为名字添加不进去，我们该怎么办？<br />可以继续使用外部比较器去比较规则<br />姓名相同的情况下再按照年龄去进行比较<br />也就是说我们外部比较器的规则可以有N多个<br />我们让它先按照英文字母，再按照年龄进行比较<br />还是得先向下年龄转换<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559995734819-d3a890e7-aedc-4bc7-834c-2c0e76e9bd72.png#align=left&display=inline&height=77&name=image.png&originHeight=154&originWidth=922&size=113861&status=done&width=461)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559995722149-1fb64a6e-bc21-42f3-9421-00bcd0c2b546.png#align=left&display=inline&height=142&name=image.png&originHeight=283&originWidth=812&size=169746&status=done&width=406)<br />我们再换下比较器<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559999311509-538ecca3-cb17-4788-bb92-78370f8835e8.png#align=left&display=inline&height=37&name=image.png&originHeight=74&originWidth=669&size=84373&status=done&width=334.5)<br />就按照我们希望的排布了

TreeSet源码分析<br />无参构造方法<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559999362804-549244f9-d1ab-4a56-853c-67eab1f88713.png#align=left&display=inline&height=56&name=image.png&originHeight=111&originWidth=596&size=51443&status=done&width=298)<br />调用了本类的一个带参构造方法<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559999416866-c2c3600b-6718-446f-9b7b-0f9396b92f5e.png#align=left&display=inline&height=31&name=image.png&originHeight=62&originWidth=346&size=18041&status=done&width=173)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559999440098-442ab7ea-5927-40cd-a9ce-9d6639b80806.png#align=left&display=inline&height=19&name=image.png&originHeight=38&originWidth=555&size=29932&status=done&width=277.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559999452463-15bda770-0dba-4cc4-9d44-3a1381b007d9.png#align=left&display=inline&height=46&name=image.png&originHeight=91&originWidth=572&size=45129&status=done&width=286)<br />把m赋给了成员变量<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559999506253-59603167-60d2-4946-ba73-34aaf5ba5ca9.png#align=left&display=inline&height=14&name=image.png&originHeight=28&originWidth=969&size=46668&status=done&width=484.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559999525956-c7ce97d8-390a-4661-a826-99afdf8c15cf.png#align=left&display=inline&height=24&name=image.png&originHeight=47&originWidth=454&size=21206&status=done&width=227)

带参构造方法<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559999628196-0900bb4b-c247-46e8-88bb-5008e254e189.png#align=left&display=inline&height=55&name=image.png&originHeight=109&originWidth=906&size=94017&status=done&width=453)<br />传入的是一个比较器<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559999648199-f50bf719-d5c6-46a8-a7fc-9b5692316f8e.png#align=left&display=inline&height=54&name=image.png&originHeight=108&originWidth=573&size=51220&status=done&width=286.5)<br />将局部变量的值赋给了成员变量

添加<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559999685177-c077f0cf-fec1-4a13-b620-52bea23eeeec.png#align=left&display=inline&height=49&name=image.png&originHeight=98&originWidth=603&size=54885&status=done&width=301.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559999777916-4e6fc8fd-a373-4fc5-b88a-0a5e97d2e965.png#align=left&display=inline&height=26&name=image.png&originHeight=53&originWidth=649&size=44177&status=done&width=324.5)<br />传入的这个元素是放map里作为键的<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559999765667-74a7a283-a6cd-4cb2-937e-9ef6e69b636d.png#align=left&display=inline&height=19&name=image.png&originHeight=38&originWidth=859&size=44515&status=done&width=429.5)<br />用map进行比较外部比较器不为空用外部比较器去比较，<br />外部比较器不为空的话再用内部比较器去比较<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559999873752-56285134-52d0-4a94-8d42-9afd6ed4a6b9.png#align=left&display=inline&height=102&name=image.png&originHeight=203&originWidth=545&size=87511&status=done&width=272.5)小于0左子树，大于0右子树，相等就替换

![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559999905432-94a56c42-1d21-4fdd-b790-3c9173219b98.png#align=left&display=inline&height=22&name=image.png&originHeight=43&originWidth=170&size=11219&status=done&width=85)<br />treemap里的一个内部类<br />实现Map里Entry的这一接口<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559999942893-065bd51e-65a1-42cf-8d68-498ea6af58a5.png#align=left&display=inline&height=37&name=image.png&originHeight=74&originWidth=928&size=63915&status=done&width=464)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559999964941-e31639f4-117d-412e-be28-7dd7d0f0266b.png#align=left&display=inline&height=126&name=image.png&originHeight=251&originWidth=914&size=130394&status=done&width=457)<br />可以看出这是一个红黑树<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1559999988223-785beb15-1137-4ed8-8834-40ca2851ac55.png#align=left&display=inline&height=49&name=image.png&originHeight=97&originWidth=345&size=30955&status=done&width=172.5)获取键的方法<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560000006681-fe3e1f8c-6ba4-4fa1-95f4-8f7b2f459fb8.png#align=left&display=inline&height=60&name=image.png&originHeight=120&originWidth=399&size=37538&status=done&width=199.5)获取值的方法

再回头看treeSet里的size方法<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560000079648-199e64f5-4b1b-496d-b984-1883f2dad099.png#align=left&display=inline&height=54&name=image.png&originHeight=108&originWidth=373&size=35496&status=done&width=186.5)<br />调用的还是treeMap里的方法<br />在使用treeSet的时候，底层仍然是在使用treeMap



