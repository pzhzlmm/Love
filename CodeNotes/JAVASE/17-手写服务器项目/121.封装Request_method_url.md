# 121.封装Request_method_url

![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560409872179-a9e80e8b-51be-4a4c-a212-bc9c34c0630e.png#align=left&display=inline&height=201&name=image.png&originHeight=402&originWidth=469&size=72689&status=done&width=234.5)

定义开始启动方法

![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560409993723-1a683c60-606a-4f0e-8aba-c6b9c3d0271f.png#align=left&display=inline&height=236&name=image.png&originHeight=473&originWidth=807&size=244227&status=done&width=403.5)<br />trycatch一下,然后监听一下是否有客户机发送请求<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560410050324-3c3620b1-c5d1-4972-94e2-74f4e977bf40.png#align=left&display=inline&height=248&name=image.png&originHeight=496&originWidth=753&size=224381&status=done&width=376.5)

编写接收方法<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560410122804-dab2c0f3-3875-4b10-a61e-03dfb8678f57.png#align=left&display=inline&height=166&name=image.png&originHeight=331&originWidth=759&size=194567&status=done&width=379.5)<br />然后再trycatch一下<br />编写调用本类方法的启动的方法<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560410203510-352189b4-46a0-4dab-911f-afce54a2ac83.png#align=left&display=inline&height=83&name=image.png&originHeight=165&originWidth=768&size=74849&status=done&width=384)

测试<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560410236764-49334620-f84e-4b32-aebc-791da0be16c6.png#align=left&display=inline&height=113&name=image.png&originHeight=225&originWidth=753&size=160064&status=done&width=376.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560410258366-0ae3840b-2808-4f20-b71f-f06a9d681660.png#align=left&display=inline&height=72&name=image.png&originHeight=143&originWidth=416&size=23466&status=done&width=208)<br />效果<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560410268253-da5e02c6-b3d5-4c7e-b619-30e05e3cb8ce.png#align=left&display=inline&height=168&name=image.png&originHeight=335&originWidth=794&size=285921&status=done&width=397)<br />服务器端就接收到了客户端的请求


但我们只是访问到了服务器,但并没有写自己的具体的html实现登录,因此接下来编写html去封装我们的请求信息<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560410471041-0441bfc7-6873-4f2b-8e63-56f32c3712ab.png#align=left&display=inline&height=312&name=image.png&originHeight=624&originWidth=1463&size=575145&status=done&width=731.5)<br />name相同代表是一组<br />效果:<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560410491110-989ddfbe-b6e7-4d0e-8dc8-2942c660d143.png#align=left&display=inline&height=160&name=image.png&originHeight=319&originWidth=652&size=75883&status=done&width=326)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560410755187-7a7867cb-e5a6-428f-938d-1a4ce95e9ac4.png#align=left&display=inline&height=38&name=image.png&originHeight=75&originWidth=710&size=34207&status=done&width=355)<br />html写完后就开始封装我们的请求

写请求<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560410547175-e1b95c73-798c-48e5-a98e-d3a97546b955.png#align=left&display=inline&height=274&name=image.png&originHeight=548&originWidth=1012&size=280211&status=done&width=506)<br />这部分是我们获取请求的内容,我们先 注释了封装请求信息


找到我们上次写的![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560410627436-fa6acd70-0f3c-4042-9493-cfb8fa74ed00.png#align=left&display=inline&height=23&name=image.png&originHeight=45&originWidth=152&size=9785&status=done&width=76)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560410953275-1ef252cd-3496-4acc-a9b0-5dda9956fd5c.png#align=left&display=inline&height=176&name=image.png&originHeight=352&originWidth=1161&size=277433&status=done&width=580.5)<br />分解请求方式,因为请求方式不同,参数位置也会不同<br />请求的url不同,其调用的servlet也不同<br />另,<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560410795408-7bc11384-64cf-4f2c-bcbe-4ed872a32700.png#align=left&display=inline&height=28&name=image.png&originHeight=55&originWidth=692&size=40963&status=done&width=346)<br />名称相同,值不同(即一个名称对应了N多个值),这种情况下我们可以使用map集合,将那么做为键,将n多的值作为map中的值,这个值可以放在list的集合之中,如<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560410994757-8cebcb83-4038-4f68-bfd4-16e42cb19342.png#align=left&display=inline&height=109&name=image.png&originHeight=218&originWidth=881&size=155249&status=done&width=440.5)<br />另,<br />请求是分行的,请求方式和请求路径是有空格的<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560411042166-dc762704-6dfb-4934-862d-3c2e51366563.png#align=left&display=inline&height=68&name=image.png&originHeight=136&originWidth=341&size=64500&status=done&width=170.5)路径和协议之间也有空格,而且还存在换行<br />因而我们定义<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560411098333-09f2563c-7b86-4341-90a5-84872b20a805.png#align=left&display=inline&height=30&name=image.png&originHeight=60&originWidth=710&size=68916&status=done&width=355)<br />另,<br />编写构造方法,对属性进行初始化<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560411140233-226a63a7-3b8f-40a3-97d1-7cf41c3b3c26.png#align=left&display=inline&height=108&name=image.png&originHeight=215&originWidth=910&size=115396&status=done&width=455)<br />再编写个带参构造方法<br />因为我们的输入流是要通过clink获得的<br />读取这些内容,读到字节数组中来,然后得到一个字符串,即请求的字符串<br />就这样我们就读到了请求信息<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560411336087-9a462980-a886-4c10-8722-a8fb0ccb4ef5.png#align=left&display=inline&height=112&name=image.png&originHeight=224&originWidth=603&size=136463&status=done&width=301.5)<br />trycatch一下,出错直接结束<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560411450729-0292b050-7597-43fa-81a0-9d73b8bf94f8.png#align=left&display=inline&height=173&name=image.png&originHeight=346&originWidth=597&size=183633&status=done&width=298.5)<br />然后调用一下分解请求信息的方法

分解请求信息<br />读到请求信息之后,要对请求信息进行分解<br />请求方式不同参数位置也不相同,post方式会在正文当中,如果是get会和路径在一起<br />但方式路径都是在第一行当中,所以我们要从请求的字符串中获取第一行<br />(获取到换行即可)![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560411683456-c67a5f67-b3c7-4cd6-8fb7-73ee9baf0404.png#align=left&display=inline&height=33&name=image.png&originHeight=66&originWidth=560&size=46604&status=done&width=280)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560411629024-a6c60a4f-148b-4b0f-b9ee-ca81b7b34421.png#align=left&display=inline&height=36&name=image.png&originHeight=72&originWidth=1047&size=84131&status=done&width=523.5)<br />从0到第一个换行 substring含头不含尾,刚刚好到换行之前<br />然后再trim去下空格<br />即<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560411729986-19ab61be-16f1-4c99-ab79-e6873f276a02.png#align=left&display=inline&height=296&name=image.png&originHeight=591&originWidth=2373&size=403121&status=done&width=1186.5)<br />继续分<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560411837364-d96a08ae-dbd3-4a62-9625-c64cef883ca5.png#align=left&display=inline&height=45&name=image.png&originHeight=90&originWidth=747&size=81557&status=done&width=373.5)<br />  分<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560412129768-471617b5-9842-47e8-9b03-579a5a23bfe7.png#align=left&display=inline&height=35&name=image.png&originHeight=69&originWidth=1025&size=97047&status=done&width=512.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560412112559-69797dbe-df63-4af7-9402-92fcb50ab5bf.png#align=left&display=inline&height=20&name=image.png&originHeight=40&originWidth=955&size=54666&status=done&width=477.5)<br />判断<br />如果是get<br />![](https://cdn.nlark.com/yuque/0/2019/png/349894/1560412218515-eebe7b96-e881-4e8e-838e-e3bc80bb4cdc.png#align=left&display=inline&height=18&originHeight=36&originWidth=539&status=done&width=269)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560412259088-9fa89b82-e745-4c8d-973c-76482730b6cb.png#align=left&display=inline&height=121&name=image.png&originHeight=242&originWidth=861&size=166081&status=done&width=430.5)<br />?之前 是路径,?之后是参数,一次选用?进行分割<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560412358361-070b4e9a-8359-4ba7-b11e-db99250da68f.png#align=left&display=inline&height=26&name=image.png&originHeight=52&originWidth=112&size=6103&status=done&width=56)java中有些特殊符号必须包含两个斜线<br />然后再用定义的数组去存储请求参数<br />如果是post<br />url在正文当中,即最后一行<br />怎么找最后一行?找最后一个换行的位置,并去掉空格<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560412513958-e42604bd-a209-4d60-a4a4-65f639433c2b.png#align=left&display=inline&height=62&name=image.png&originHeight=123&originWidth=1042&size=92383&status=done&width=521)<br />没有参数直接return<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560412528174-1fcdc907-752d-4c3e-8a99-93c9bb5127f9.png#align=left&display=inline&height=47&name=image.png&originHeight=93&originWidth=475&size=34552&status=done&width=237.5)

在服务器当中创建请求的对象,将字节输入流传入<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560412635366-24d743df-7fa3-4de8-b41f-99a50a48e1a5.png#align=left&display=inline&height=210&name=image.png&originHeight=419&originWidth=975&size=311866&status=done&width=487.5)


测试<br /> ![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560412563671-45e87724-59a9-4530-99c0-208fcb7172a1.png#align=left&display=inline&height=130&name=image.png&originHeight=260&originWidth=742&size=123906&status=done&width=371)<br />在![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560412683923-88d8bc1a-12cf-4010-b745-c3a1f21e26b8.png#align=left&display=inline&height=39&name=image.png&originHeight=78&originWidth=493&size=41314&status=done&width=246.5)中调用<br />网页填写信息后:<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560412693193-f2404d4f-96eb-4271-91d7-c03e0e5d7383.png#align=left&display=inline&height=88&name=image.png&originHeight=175&originWidth=702&size=110012&status=done&width=351)<br />改为post<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560412720130-240ea750-4ff5-4bc5-b227-c92ec1729d9a.png#align=left&display=inline&height=74&name=image.png&originHeight=148&originWidth=737&size=123170&status=done&width=368.5)<br />封装完毕,已经可以提取了
