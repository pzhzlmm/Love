# 110.ThreadLocal是什么_JDK底层原理


1. 简述什么是ThreadLocal？<br />
  1. 本地线程,其实就是一容器用于存放线程中的局部变量
2. ThreadLocal主要的四个方法是什么？分别表示什么含义？
  1. T get():返回当前线程的此线程局部变量的副本中的值.
  1. protected T initialVapue () 返回此线程高部变量的当前线程的初始值".
  1. void remove () 删除此线程局部变量的当前线程的值.
  1. void set(T value) 将当前线程的此线程局部变量的副本设置为指定的值.

![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560330098531-87f6ebf1-1f9d-4fb0-b0bc-598e4cd7db7e.png#align=left&display=inline&height=107&name=image.png&originHeight=213&originWidth=712&size=106564&status=done&width=356)

![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560330174369-21080752-9248-43d7-8b02-842f10cd8160.png#align=left&display=inline&height=48&name=image.png&originHeight=95&originWidth=461&size=32230&status=done&width=230.5)<br />序列化,递增或者递减的序列

我们去编写一个序列的接口<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560330277468-48563c41-b5b8-4520-ac41-ef58a5548960.png#align=left&display=inline&height=107&name=image.png&originHeight=214&originWidth=1003&size=128839&status=done&width=501.5)<br />编写实现类<br />里面有个静态变量能被所有对象所共享<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560330325121-da2a7bbe-69af-43cf-bcc6-1db05d8f88ad.png#align=left&display=inline&height=190&name=image.png&originHeight=379&originWidth=855&size=201540&status=done&width=427.5)<br />再实现多线程去访问它<br />序列是共享资源,因为每一个线程都要操作它<br />在构造方法中传入这个序列,将局部变量的值去赋给成员变量<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560330497060-9a6fdfd9-28af-45f8-a715-d42356d52fd1.png#align=left&display=inline&height=218&name=image.png&originHeight=436&originWidth=1026&size=256927&status=done&width=513)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560330480620-f8d17247-3242-4ef1-a17a-c4fe3b098742.png#align=left&display=inline&height=27&name=image.png&originHeight=53&originWidth=1024&size=66413&status=done&width=512)<br />测试类<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560330554257-bee5db3b-bd8f-433c-a0f8-639a031e6933.png#align=left&display=inline&height=227&name=image.png&originHeight=453&originWidth=759&size=292471&status=done&width=379.5)<br />效果<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560330572112-73832739-4d72-4e6e-9013-2b9840495438.png#align=left&display=inline&height=190&name=image.png&originHeight=380&originWidth=197&size=98121&status=done&width=98.5)<br />目前是这样<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560330623372-509c4184-5f0d-4b99-889b-881f08a568d8.png#align=left&display=inline&height=192&name=image.png&originHeight=383&originWidth=715&size=133225&status=done&width=357.5)<br />number是静态变量,就这么从1一直增加到了9(几个线程共同访问的)<br />我们现在想要的是ABC三个线程都去访问自己的number变量<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560330705216-42df4c64-f0b8-4823-a3cc-46f0d7fac446.png#align=left&display=inline&height=158&name=image.png&originHeight=316&originWidth=535&size=95515&status=done&width=267.5)<br />而这个number本身是静态的,如何让其他number都拥有这个number的副本呢?<br />这个时候就用到了ThreadLocal

实现类2<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560388036521-b4381b84-cee7-4982-a4c2-e6fa96425c93.png#align=left&display=inline&height=243&name=image.png&originHeight=485&originWidth=1002&size=333578&status=done&width=501)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560330784263-1cc242ad-bd01-4999-9926-0ba397698247.png#align=left&display=inline&height=32&name=image.png&originHeight=63&originWidth=1029&size=104126&status=done&width=514.5)<br />实现效果<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560388060697-c99f2c2d-0cd3-4f74-961b-34cb4772ee25.png#align=left&display=inline&height=188&name=image.png&originHeight=375&originWidth=229&size=103883&status=done&width=114.5)<br />每个线程都操作了自己的number

源码分析<br />T get():返回当前线程的此线程局部变量的副本中的值.<br />protected T initialVapue () 返回此线程高部变量的当前线程的初始值".<br />void remove () 删除此线程局部变量的当前线程的值.<br />void set(T value) 将当前线程的此线程局部变量的副本设置为指定的值.<br />static <S> ThreadLocal<S> withInitial (Supplier<? extends S> supplier) 创建线程局部变量.<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560388128776-421db374-73c3-4fc7-b100-b3f4e57badd9.png#align=left&display=inline&height=316&name=image.png&originHeight=632&originWidth=1161&size=293846&status=done&width=580.5)<br />赋值<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560388190652-4b0ec2c9-8cca-4493-b014-87f16fb1a881.png#align=left&display=inline&height=309&name=image.png&originHeight=617&originWidth=1000&size=426995&status=done&width=500)<br />ThreadLocals是一个map类型<br />经过赋值之后,每个线程都有自己的,互不干扰的静态变量number<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560388593815-e382487e-128d-4c57-b315-628a0ee21872.png#align=left&display=inline&height=278&name=image.png&originHeight=555&originWidth=1586&size=456867&status=done&width=793)

取值源码<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560388165850-981ca6e3-bc1c-440d-af7f-23984ef05b5e.png#align=left&display=inline&height=193&name=image.png&originHeight=386&originWidth=905&size=218843&status=done&width=452.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560388695735-a0dcb4cd-3ff4-440f-936c-720e521c16b7.png#align=left&display=inline&height=158&name=image.png&originHeight=316&originWidth=923&size=161965&status=done&width=461.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560388733902-6c165c91-cc31-407d-b720-85db202f5d7b.png#align=left&display=inline&height=253&name=image.png&originHeight=505&originWidth=1533&size=471366&status=done&width=766.5)<br />每次取值的都是当前ThreadLocalMap的值,对其他线程中的number不产生影响

Thread里有个成员变量就是threadLocals<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560388243605-69c5df73-0be7-4842-83ca-c2458662f4dc.png#align=left&display=inline&height=163&name=image.png&originHeight=325&originWidth=895&size=249755&status=done&width=447.5)<br />ThreadLocalMap是ThreadLocal里的一个静态内部类

