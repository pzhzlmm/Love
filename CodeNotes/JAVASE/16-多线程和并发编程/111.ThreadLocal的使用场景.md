# 111.ThreadLocal的使用场景

<a name="C3bJi"></a>
## 导问
1. 简述ThreadLocal的应用场景？
  1. 用来解决数据库连接,Session管理等,即多个线程需要自己独立的static变量


<br />ThreadLocal的使用场景为：用来解决数据库连接、Session<br />管理等<br />7.1 ThreadLocal在数据库连接上的应用<br />当你在一个类中使用static 成员变量时，一定要问自己这<br />个static成员变量需要考虑“线程安全吗？”（也就是说多个<br />线程需要自己独立的static 成员变量吗？ ）如果需要那就需<br />要使用ThreadLocal。

DBUitl:数据库的连接<br />要想实现数据库的连接,首先得有一个mysql的jar包<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560388986385-e652304d-4cf3-43b7-9a3a-34f647cc3f3b.png#align=left&display=inline&height=106&name=image.png&originHeight=212&originWidth=840&size=184615&status=done&width=420)<br />负责与数据库进行连接<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560389010455-57823c58-4e02-4598-b615-8a1d3fe9a72e.png#align=left&display=inline&height=211&name=image.png&originHeight=421&originWidth=939&size=221548&status=done&width=469.5)<br />这个方法还有Connection都是静态变量

增加Dao类,添加增删改查方法,然后使用多线程去访问DBUtil(即多个线程去获取连接)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560389179822-81151a69-bcb3-4182-b07e-834b7fd432b5.png#align=left&display=inline&height=350&name=image.png&originHeight=700&originWidth=1506&size=540161&status=done&width=753)<br />增加测试类<br />接着编写线程类用Runnable接口实现<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560389277828-e2524e16-d589-48b7-a3f0-7c6daa26e9d5.png#align=left&display=inline&height=349&name=image.png&originHeight=698&originWidth=752&size=335913&status=done&width=376)<br />效果:<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560389314939-3ebbf8d1-1c56-4b76-8df5-574713554353.png#align=left&display=inline&height=234&name=image.png&originHeight=467&originWidth=987&size=675727&status=done&width=493.5)<br />可以发现这部分获取的连接都是相同的<br />那么连接为什么有相同有不同呢?<br />我们使用多线程去操作,如果connection为空的话,那么它就会去获取连接,有可能会去多创建conn,Colection对象,第一个发现为空,被换下来了,第二个发现为空被换下来了,第三个发现为空被换下来了,有可能每个线程都创建了连接,然后这些连接就会进行覆盖<br />如果再去进行增删改查操作,那么数据就会不安全

每个客户端进来都是一个线程,服务器里有个静态的共享的Connection叫conn<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560389836563-2a3f506d-86dd-4625-b79f-bdea40fc98ea.png#align=left&display=inline&height=325&name=image.png&originHeight=650&originWidth=476&size=185958&status=done&width=238)<br />加锁效率会低,不加锁不安全<br />如此我们考虑这个连接需要共享么?共享没有什么意义还会带来很多别的问题

法二 我们把所有静态都去掉<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560389910394-0c0868cb-8d1d-4951-b082-620f995ce140.png#align=left&display=inline&height=265&name=image.png&originHeight=529&originWidth=681&size=313316&status=done&width=340.5)<br />带来的问题是,我们执行每一个方法到时候我们都需要重新创建连接对象<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560390004318-bf6ffd41-1b50-4a3a-96ac-23269c4aff1d.png#align=left&display=inline&height=347&name=image.png&originHeight=694&originWidth=1209&size=742324&status=done&width=604.5)<br />修改之后查看效果<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560390024729-1d25878f-a157-4acf-bf7d-45132098d433.png#align=left&display=inline&height=224&name=image.png&originHeight=448&originWidth=948&size=641322&status=done&width=474)<br />增删改查分别创建了不同的连接对象<br />如此就会造成服务器端的压力<br />要不断地创建对象还要不断地去销毁这些对象,而且还严重影响程序的执行效率<br />每个方法中都会创建连接,而这些连接都要和数据库连接起来<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560390224710-87a5f5ab-da9b-47fb-8e39-2560ae8a6bcb.png#align=left&display=inline&height=306&name=image.png&originHeight=612&originWidth=551&size=140398&status=done&width=275.5)

法三,ThreadUtil<br />先要去判断是否有连接<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560390434252-2c8483d0-a956-49f8-bd19-b12e6d26fdc6.png#align=left&display=inline&height=371&name=image.png&originHeight=741&originWidth=1401&size=540777&status=done&width=700.5)<br />如果没有的话就要设置连接,放到ThreadLocal当中<br />接下来设置关闭的方法<br />如果连接不等于空,那么就去把连接关闭,关了之后,把其置为空<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560390591570-8828dcf9-fb39-49ed-9e5a-3a9a69ea300f.png#align=left&display=inline&height=201&name=image.png&originHeight=401&originWidth=713&size=175172&status=done&width=356.5)<br />然后在获取连接的部分加个synchronized,这样就保证了数据的同步,来防止数据的错乱一级数据的不安全性<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560390657080-f3fc65d1-0579-4621-ae2a-31e9a0df90b5.png#align=left&display=inline&height=207&name=image.png&originHeight=414&originWidth=789&size=252168&status=done&width=394.5)<br />然后修改我们的Dao类<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560390755733-0698e611-b518-473e-ba88-6cf4e12155ad.png#align=left&display=inline&height=322&name=image.png&originHeight=643&originWidth=1449&size=600370&status=done&width=724.5)<br />效果<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560390787022-26dd87f0-debd-46c0-9643-7de12bffac3e.png#align=left&display=inline&height=205&name=image.png&originHeight=409&originWidth=1059&size=638726&status=done&width=529.5)<br />可以看到0是完全相同的,现在就是每个连接获取到了他们自己的静态变量<br />图示<br />每个线程都会有静态的连接的副本,增删改查获取连接就可以了,线程之间不会产生影响<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560390973011-f91fbacc-ab93-4c88-8ca0-1727d2dc5e23.png#align=left&display=inline&height=256&name=image.png&originHeight=512&originWidth=514&size=100982&status=done&width=257)

