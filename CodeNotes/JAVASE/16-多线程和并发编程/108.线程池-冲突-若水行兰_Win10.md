# 108.线程池

<a name="J2LBL"></a>
## 导问
1. 简述什么是线程池？
  1. 创建和销毁对象是非常耗费时间的,于是就定义了线程池去存放线程空间
2. 使用线程池有哪些好处？
  1. 提高了响应速度(减少了创建新线程的时间)
  1. 降低了资源消耗(重复利用线程池中线程,不需要每次都创建)
  1. 提高线程的可管理性,避免线程无限制创建,从而销毁 系统资源,降低系统稳定性,甚至内存溢出或者CPU耗尽

线程池:存放线程的空间<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560327954328-f86e02fe-8e06-42f9-a75b-9f670146d0ca.png#align=left&display=inline&height=181&name=image.png&originHeight=362&originWidth=723&size=220748&status=done&width=361.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560328025035-b9dc0fee-9428-4ec4-8331-5bb1e62fda81.png#align=left&display=inline&height=161&name=image.png&originHeight=322&originWidth=720&size=195638&status=done&width=360)

<a name="WWK8C"></a>
### 线程池的好处
提高了响应速度(减少了创建新线程的时间)<br />降低了资源消耗(重复利用线程池中线程,不需要每次都创建)<br />提高线程的可管理性,避免线程无限制创建,从而销毁 系统资源,降低系统稳定性,甚至内存溢出或者CPU耗尽<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560328135971-a4f8b546-a848-4c35-bbac-9ae55adb056d.png#align=left&display=inline&height=110&name=image.png&originHeight=220&originWidth=521&size=95369&status=done&width=260.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560328193022-bb120882-ff6f-4f7d-b03d-5320ef954240.png#align=left&display=inline&height=416&name=image.png&originHeight=831&originWidth=1496&size=781078&status=done&width=748)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560328203597-abea4a5d-ced5-4262-9ad7-9b9796955c33.png#align=left&display=inline&height=81&name=image.png&originHeight=162&originWidth=538&size=73323&status=done&width=269)

测试类<br />创建<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560328284640-9e89d159-97f2-43bb-9bee-9f486d696370.png#align=left&display=inline&height=123&name=image.png&originHeight=245&originWidth=966&size=291667&status=done&width=483)<br />1源码<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560328393040-c271fed0-0793-46e1-b393-143edf8f2bc2.png#align=left&display=inline&height=96&name=image.png&originHeight=192&originWidth=1030&size=186950&status=done&width=515)<br />传过来1个最少是1个最多也是1个<br />2源码<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560328361375-b077ee3b-d9ab-4036-8d58-82b83a70c3ca.png#align=left&display=inline&height=85&name=image.png&originHeight=170&originWidth=1041&size=162739&status=done&width=520.5)<br />传过来10个最少是10个最多也是10个<br />3源码<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560328303225-31f0b97b-c839-4b0d-9dd6-10f436fe7103.png#align=left&display=inline&height=161&name=image.png&originHeight=321&originWidth=1026&size=204991&status=done&width=513)<br />创建了个线程池,最少是0个,最大是Value个

![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560328417540-6bc06ffe-0c85-482b-849f-a06e5f852152.png#align=left&display=inline&height=19&name=image.png&originHeight=37&originWidth=461&size=31040&status=done&width=230.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560328527931-0eec915b-6a33-4782-ab22-d318235bf9d3.png#align=left&display=inline&height=255&name=image.png&originHeight=509&originWidth=784&size=267090&status=done&width=392)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560328561937-ad1c515a-554c-4531-9e50-80975b5c45d9.png#align=left&display=inline&height=38&name=image.png&originHeight=75&originWidth=385&size=47404&status=done&width=192.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560328572943-2268158f-be1f-468c-b591-8fb171782711.png#align=left&display=inline&height=36&name=image.png&originHeight=71&originWidth=309&size=27991&status=done&width=154.5)

先使用只有一个线程的线程池,执行20次,每次2秒,因为线程池里只有一个任务,所以它是一个一个执行的,执行效率要低一些<br />再使用有十个线程的线程池,也就是说有10个线程去执行这个任务,执行20次,每次2秒,10个线程只需要4秒<br />最后执行可动态改变的线程池,我总共有20个任务它将创建20个线程,耗时2秒

![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560328882952-5397ae93-1a3f-4b20-9bcb-3d1a87b4eb08.png#align=left&display=inline&height=18&name=image.png&originHeight=36&originWidth=468&size=29353&status=done&width=234)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560329033953-a5cea874-8fcf-40b8-81a2-103a0697e892.png#align=left&display=inline&height=243&name=image.png&originHeight=486&originWidth=853&size=252473&status=done&width=426.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560329058304-b69feced-d820-4071-922e-3690165445bc.png#align=left&display=inline&height=34&name=image.png&originHeight=67&originWidth=284&size=24474&status=done&width=142)<br />使用只有一个线程的线程池和有十个线程的线程池效率似乎没有提高,因为这里我们要获取返回值,执行输出的时候只有将任务执行完毕之后,下一个任务才会开始:![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560329211907-f90c6eb2-2ffd-4901-ada4-6ba6110dd1fa.png#align=left&display=inline&height=67&name=image.png&originHeight=133&originWidth=480&size=73861&status=done&width=240)<br />所以哪怕有十个线程,也是要一个一个执行的,并没有比只有一个线程的线程池的效率高

解决方案<br />循环的时候先不输出值,把我们创建的任务 分发出去,如果是有十个线程的线程池,分发两次,也分发完毕了<br />所以这次我们把我们的任务添加到一个集合当中<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560329343676-2a1fb2bd-f7b4-4186-a718-063fef8ce6df.png#align=left&display=inline&height=121&name=image.png&originHeight=242&originWidth=760&size=257526&status=done&width=380)<br />然后我们进入循环之后,每创建一个一个任务,就把这个任务添加到集合当中<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560329406960-50344223-7a87-44ca-b0d7-f4e331f97674.png#align=left&display=inline&height=233&name=image.png&originHeight=466&originWidth=617&size=217158&status=done&width=308.5)<br />等循环结束再去遍历集合<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/349894/1560329445482-baea91db-0020-4c21-9b44-aa1bbe2fb1a9.png#align=left&display=inline&height=93&name=image.png&originHeight=185&originWidth=602&size=109406&status=done&width=301)
